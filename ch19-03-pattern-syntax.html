<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>模式语法 - Rust 程序设计语言 简体中文版</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 程序设计语言 简体中文版</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/KaiserY/trpl-zh-cn/tree/main" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/KaiserY/trpl-zh-cn/edit/main/src/ch19-03-pattern-syntax.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="模式语法"><a class="header" href="#模式语法">模式语法</a></h2>
<!-- https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md -->
<!-- commit 56ec353290429e6547109e88afea4de027b0f1a9 -->
<p>在本节中，我们收集了模式中所有有效的语法，并讨论为什么以及何时你可能要使用这些语法。</p>
<h3 id="匹配字面值"><a class="header" href="#匹配字面值">匹配字面值</a></h3>
<p>如第六章所示，可以直接匹配字面值模式。如下代码给出了一些例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!("one"),
        2 =&gt; println!("two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
<span class="boring">}</span></code></pre></pre>
<p>这段代码会打印 <code>one</code> 因为 <code>x</code> 的值是 1。如果希望代码获得特定的具体值，则该语法很有用。</p>
<h3 id="匹配命名变量"><a class="header" href="#匹配命名变量">匹配命名变量</a></h3>
<p>命名变量（Named variables）是匹配任何值的不可反驳模式，这在之前已经使用过数次。然而，当在 <code>match</code>、<code>if let</code> 或 <code>while let</code> 表达式中使用命名变量时，会出现一些复杂情况。由于这些表达式会开始一个新作用域，作为模式一部分在表达式内部声明的变量会遮蔽外部同名变量，这与所有变量的遮蔽规则一致。在示例 19-11 中，声明了一个值为 <code>Some(5)</code> 的变量 <code>x</code> 和一个值为 <code>10</code> 的变量 <code>y</code>。接着在值 <code>x</code> 上创建了一个 <code>match</code> 表达式。观察匹配分支中的模式和结尾的 <code>println!</code>，并在运行此代码或进一步阅读之前推断这段代码会打印什么。</p>
<p><span class="filename">文件名：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(y) =&gt; println!("Matched, y = {y}"),
        _ =&gt; println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">示例 19-11: 一个 <code>match</code> 语句其中一个分支引入了遮蔽变量 <code>y</code></span></p>
<p>让我们看看当 <code>match</code> 语句运行的时候发生了什么。第一个匹配分支的模式并不匹配 <code>x</code> 中定义的值，所以代码继续执行。</p>
<p>第二个匹配分支中的模式引入了一个新变量 <code>y</code>，它会匹配任何 <code>Some</code> 中的值。因为我们在 <code>match</code> 表达式的新作用域中，这是一个新变量，而不是开头声明为值 10 的那个 <code>y</code>。这个新的 <code>y</code> 绑定会匹配任何 <code>Some</code> 中的值，在这里是 <code>x</code> 中的值。因此这个 <code>y</code> 绑定了 <code>x</code> 中 <code>Some</code> 内部的值。这个值是 5，所以这个分支的表达式将会执行并打印出 <code>Matched, y = 5</code>。</p>
<p>如果 <code>x</code> 的值是 <code>None</code> 而不是 <code>Some(5)</code>，头两个分支的模式不会匹配，所以会匹配下划线。这个分支的模式中没有引入变量 <code>x</code>，所以此时表达式中的 <code>x</code> 会是外部没有被遮蔽的 <code>x</code>。在这个假想的例子中，<code>match</code> 将会打印 <code>Default case, x = None</code>。</p>
<p>一旦 <code>match</code> 表达式执行完毕，其作用域也就结束了，同理内部 <code>y</code> 的作用域也结束了。最后的 <code>println!</code> 会打印 <code>at the end: x = Some(5), y = 10</code>。</p>
<p>为了创建能够比较外部 <code>x</code> 和 <code>y</code> 的值，又不引入新的变量去遮蔽已有 <code>y</code> 的 <code>match</code> 表达式，我们需要相应地使用带有条件的匹配守卫（match guard）。我们稍后将在 <a href="#%E5%8C%B9%E9%85%8D%E5%AE%88%E5%8D%AB%E6%8F%90%E4%BE%9B%E7%9A%84%E9%A2%9D%E5%A4%96%E6%9D%A1%E4%BB%B6">“匹配守卫提供的额外条件”</a> 这一小节讨论匹配守卫。</p>
<h3 id="多个模式"><a class="header" href="#多个模式">多个模式</a></h3>
<p>在 <code>match</code> 表达式中，可以使用 <code>|</code> 语法匹配多个模式，它代表 <strong>或</strong>（<em>or</em>）运算符模式。例如，如下代码将 <code>x</code> 的值与匹配分支相比较，第一个分支有<strong>或</strong>选项，意味着如果 <code>x</code> 的值匹配此分支的任一个值，它就会运行：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!("one or two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
<span class="boring">}</span></code></pre></pre>
<p>上面的代码会打印 <code>one or two</code>。</p>
<h3 id="通过--匹配值范围"><a class="header" href="#通过--匹配值范围">通过 <code>..=</code> 匹配值范围</a></h3>
<p><code>..=</code> 语法允许你匹配一个闭区间范围（range）内的值。在如下代码中，当模式匹配任何在给定范围内的值时，该分支会执行：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!("one through five"),
        _ =&gt; println!("something else"),
    }
<span class="boring">}</span></code></pre></pre>
<p>如果 <code>x</code> 是 1、2、3、4 或 5，第一个分支就会匹配。这个语法在匹配多个值时相比使用 <code>|</code> 运算符来表达相同的意思更为方便；如果使用 <code>|</code> 则不得不指定 <code>1 | 2 | 3 | 4 | 5</code>。相反指定范围就简短的多，特别是在希望匹配比如从 1 到 1000 的数字的时候！</p>
<p>编译器会在编译时检查范围不为空，而 <code>char</code> 和数字值是 Rust 仅有的可以判断范围是否为空的类型，所以范围只允许用于数字或 <code>char</code> 值。</p>
<p>如下是一个使用 <code>char</code> 类型值范围的例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!("early ASCII letter"),
        'k'..='z' =&gt; println!("late ASCII letter"),
        _ =&gt; println!("something else"),
    }
<span class="boring">}</span></code></pre></pre>
<p>Rust 知道 <code>'c'</code> 位于第一个模式的范围内，并会打印出 <code>early ASCII letter</code>。</p>
<h3 id="解构并分解值"><a class="header" href="#解构并分解值">解构并分解值</a></h3>
<p>也可以使用模式来解构结构体、枚举和元组，以便使用这些值的不同部分。让我们来分别看一看。</p>
<h4 id="解构结构体"><a class="header" href="#解构结构体">解构结构体</a></h4>
<p>示例 19-12 展示带有两个字段 <code>x</code> 和 <code>y</code> 的结构体 <code>Point</code>，可以通过带有模式的 <code>let</code> 语句将其分解：</p>
<p><span class="filename">文件名：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}</code></pre></pre>
<p><span class="caption">示例 19-12: 解构一个结构体的字段为单独的变量</span></p>
<p>这段代码创建了变量 <code>a</code> 和 <code>b</code> 来匹配结构体 <code>p</code> 中的 <code>x</code> 和 <code>y</code> 字段。这个例子展示了模式中的变量名不必与结构体中的字段名一致。不过通常希望变量名与字段名一致以便于理解变量来自于哪些字段。因为变量名匹配字段名是常见的，同时因为 <code>let Point { x: x, y: y } = p;</code> 包含了很多重复，所以对于匹配结构体字段的模式存在简写：只需列出结构体字段的名称，则模式创建的变量会有相同的名称。示例 19-13 展示了与示例 19-12 有着相同行为的代码，不过 <code>let</code> 模式创建的变量为 <code>x</code> 和 <code>y</code> 而不是 <code>a</code> 和 <code>b</code>：</p>
<p><span class="filename">文件名：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}</code></pre></pre>
<p><span class="caption">示例 19-13: 使用结构体字段简写来解构结构体字段</span></p>
<p>这段代码创建了变量 <code>x</code> 和 <code>y</code>，与变量 <code>p</code> 中的 <code>x</code> 和 <code>y</code> 相匹配。其结果是变量 <code>x</code> 和 <code>y</code> 包含结构体 <code>p</code> 中的值。</p>
<p>也可以使用字面值作为结构体模式的一部分进行解构，而不是为所有的字段创建变量。这允许我们测试一些字段为特定值的同时创建其他字段的变量。</p>
<p>示例 19-14 展示了一个 <code>match</code> 语句将 <code>Point</code> 值分成了三种情况：直接位于 <code>x</code> 轴上（此时 <code>y = 0</code> 为真）、位于 <code>y</code> 轴上（<code>x = 0</code>）或不在任何轴上的点。</p>
<p><span class="filename">文件名：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!("On the x axis at {x}"),
        Point { x: 0, y } =&gt; println!("On the y axis at {y}"),
        Point { x, y } =&gt; {
            println!("On neither axis: ({x}, {y})");
        }
    }
}</code></pre></pre>
<p><span class="caption">示例 19-14: 解构和匹配模式中的字面值</span></p>
<p>第一个分支通过指定字段 <code>y</code> 匹配字面值 <code>0</code> 来匹配任何位于 <code>x</code> 轴上的点。此模式仍然创建了变量 <code>x</code> 以便在分支的代码中使用。</p>
<p>类似的，第二个分支通过指定字段 <code>x</code> 匹配字面值 <code>0</code> 来匹配任何位于 <code>y</code> 轴上的点，并为字段 <code>y</code> 创建了变量 <code>y</code>。第三个分支没有指定任何字面值，所以其会匹配任何其他的 <code>Point</code> 并为 <code>x</code> 和 <code>y</code> 两个字段创建变量。</p>
<p>在这个例子中，值 <code>p</code> 因为其 <code>x</code> 包含 <code>0</code> 而匹配第二个分支，因此会打印出 <code>On the y axis at 7</code>。</p>
<p>记住 <code>match</code> 表达式一旦找到一个匹配的模式就会停止检查其它分支，所以即使 <code>Point { x: 0, y: 0}</code> 在 <code>x</code> 轴上也在 <code>y</code> 轴上，这些代码也只会打印 <code>On the x axis at 0</code>。</p>
<h4 id="解构枚举"><a class="header" href="#解构枚举">解构枚举</a></h4>
<p>本书之前曾经解构过枚举（例如第六章示例 6-5），不过当时没有明确提到解构枚举的模式需要对应枚举所定义的储存数据的方式。让我们以示例 6-2 中的 <code>Message</code> 枚举为例，编写一个 <code>match</code> 使用模式解构每一个内部值，如示例 19-15 所示：</p>
<p><span class="filename">文件名：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!("The Quit variant has no data to destructure.");
        }
        Message::Move { x, y } =&gt; {
            println!("Move in the x direction {x} and in the y direction {y}");
        }
        Message::Write(text) =&gt; {
            println!("Text message: {text}");
        }
        Message::ChangeColor(r, g, b) =&gt; {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
    }
}</code></pre></pre>
<p><span class="caption">示例 19-15: 解构包含不同类型值变体的枚举</span></p>
<p>这段代码会打印出 <code>Change the color to red 0, green 160, and blue 255</code>。尝试改变 <code>msg</code> 的值来观察其他分支代码的运行。</p>
<p>对于像 <code>Message::Quit</code> 这样没有任何数据的枚举变体，不能进一步解构其值。只能匹配其字面值 <code>Message::Quit</code>，因此模式中没有任何变量。</p>
<p>对于像 <code>Message::Move</code> 这样的类结构体枚举变体，可以采用类似于匹配结构体的模式。在变体名称后，使用大括号并列出字段变量以便将其分解以供此分支的代码使用。这里使用了示例 19-13 所展示的简写。</p>
<p>对于像 <code>Message::Write</code> 这样的包含一个元素，以及像 <code>Message::ChangeColor</code> 这样包含三个元素的类元组枚举变体，其模式则类似于用于解构元组的模式。模式中变量的数量必须与变体中元素的数量完全一致。</p>
<h4 id="解构嵌套的结构体和枚举"><a class="header" href="#解构嵌套的结构体和枚举">解构嵌套的结构体和枚举</a></h4>
<p>目前为止，所有的例子都只匹配了深度为一级的结构体或枚举，不过当然也可以匹配嵌套的项！例如，我们可以重构示例 19-15 的代码在 <code>ChangeColor</code> 消息中同时支持 RGB 和 HSV 色彩模式，如示例 19-16 所示：</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!("Change color to hue {h}, saturation {s}, value {v}");
        }
        _ =&gt; (),
    }
}</code></pre></pre>
<p><span class="caption">示例 19-16: 匹配嵌套的枚举</span></p>
<p><code>match</code> 表达式第一个分支的模式匹配一个包含 <code>Color::Rgb</code> 枚举变体的 <code>Message::ChangeColor</code> 枚举变体，然后模式绑定了三个内部的 <code>i32</code> 值。第二个分支的模式也匹配一个 <code>Message::ChangeColor</code> 枚举变体，但是其内部的枚举会匹配 <code>Color::Hsv</code> 枚举变体。我们可以在一个 <code>match</code> 表达式中指定这些复杂条件，即使会涉及到两个枚举。</p>
<h4 id="解构结构体和元组"><a class="header" href="#解构结构体和元组">解构结构体和元组</a></h4>
<p>甚至可以用复杂的方式来混合、匹配和嵌套解构模式。如下是一个复杂结构体的例子，其中结构体和元组嵌套在元组中，并将所有的原始类型解构出来：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}</span></code></pre></pre>
<p>这将复杂的类型分解成部分组件以便可以单独使用我们感兴趣的值。</p>
<p>通过模式解构是一个方便将值的各个片段分离开来单独使用的方式，比如结构体中每个单独字段的值。</p>
<h3 id="忽略模式中的值"><a class="header" href="#忽略模式中的值">忽略模式中的值</a></h3>
<p>有时忽略模式中的一些值是有用的，比如 <code>match</code> 中最后捕获全部情况的分支实际上没有做任何事，但是它确实负责匹配了所有剩余的可能值。有一些方法可以忽略模式中全部或部分值：使用 <code>_</code> 模式（我们已经见过了），在另一个模式中使用 <code>_</code> 模式，使用一个以下划线开始的名称，或者使用 <code>..</code> 忽略所剩部分的值。让我们来分别探索如何以及为什么要这么做。</p>
<h4 id="使用-_-忽略整个值"><a class="header" href="#使用-_-忽略整个值">使用 <code>_</code> 忽略整个值</a></h4>
<p>我们已经使用过下划线作为匹配但不绑定任何值的通配符模式了。虽然这作为 <code>match</code> 表达式最后的分支特别有用，也可以将其用于任意模式，包括函数参数中，如示例 19-17 所示：</p>
<p><span class="filename">文件名：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {y}");
}

fn main() {
    foo(3, 4);
}</code></pre></pre>
<p><span class="caption">示例 19-17: 在函数签名中使用 <code>_</code></span></p>
<p>这段代码会完全忽略作为第一个参数传递的值 <code>3</code>，并会打印出 <code>This code only uses the y parameter: 4</code>。</p>
<p>大部分情况当你不再需要特定函数参数时，最好修改签名不再包含无用的参数。在一些情况下忽略函数参数会变得特别有用，比如实现 trait 时，当你需要特定类型签名但是函数实现并不需要某个参数时。这样可以避免一个存在未使用的函数参数的编译警告，就跟使用命名参数一样。</p>
<h4 id="使用嵌套的-_-忽略部分值"><a class="header" href="#使用嵌套的-_-忽略部分值">使用嵌套的 <code>_</code> 忽略部分值</a></h4>
<p>也可以在一个模式内部使用<code>_</code> 忽略部分值，例如，当只需要测试部分值但在期望运行的代码中没有用到其他部分时。示例 19-18 展示了负责管理设置值的代码。业务需求是用户不允许覆盖现有的自定义设置，但是可以取消设置，也可以在当前未设置时为其提供一个值。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!("Can't overwrite an existing customized value");
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!("setting is {setting_value:?}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">示例 19-18: 当不需要 <code>Some</code> 中的值时在模式内使用下划线来匹配 <code>Some</code> 变体</span></p>
<p>这段代码会打印出 <code>Can't overwrite an existing customized value</code> 接着是 <code>setting is Some(5)</code>。在第一个匹配分支，我们不需要匹配或使用任一个 <code>Some</code> 变体中的值，但需要检测 <code>setting_value</code> 和 <code>new_setting_value</code> 是否均为 <code>Some</code> 变体。在这种情况下，我们打印出为何不改变 <code>setting_value</code>，并且不会改变它。</p>
<p>对于所有其他情况（<code>setting_value</code> 或 <code>new_setting_value</code> 任一为 <code>None</code>），这由第二个分支的 <code>_</code> 模式体现，这时确实希望允许 <code>new_setting_value</code> 变为 <code>setting_value</code>。</p>
<p>也可以在一个模式中的多处使用下划线来忽略特定值，如示例 19-19 所示，这里忽略了一个五元元组中的第二和第四个值：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!("Some numbers: {first}, {third}, {fifth}");
        }
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">示例 19-19: 忽略元组的多个部分</span></p>
<p>这会打印出 <code>Some numbers: 2, 8, 32</code>，值 <code>4</code> 和 <code>16</code> 会被忽略。</p>
<h4 id="通过在变量名开头加-_-来忽略未使用的变量"><a class="header" href="#通过在变量名开头加-_-来忽略未使用的变量">通过在变量名开头加 <code>_</code> 来忽略未使用的变量</a></h4>
<p>如果你创建了一个变量却不在任何地方使用它，Rust 通常会给你一个警告，因为未使用的变量可能会是个 bug。但是有时创建一个还未使用的变量是有用的，比如你正在设计原型或刚刚开始一个项目。这时你希望告诉 Rust 不要警告未使用的变量，为此可以用下划线作为变量名的开头。示例 19-20 中创建了两个未使用变量，不过当编译代码时只会得到其中一个的警告：</p>
<p><span class="filename">文件名：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let _x = 5;
    let y = 10;
}</code></pre></pre>
<p><span class="caption">示例 19-20: 以下划线开始变量名以便去掉未使用变量警告</span></p>
<p>这里得到了警告说未使用变量 <code>y</code>，不过没有警告说未使用 <code>_x</code>。</p>
<p>注意，只使用 <code>_</code> 和使用以下划线开头的名称有些微妙的不同：比如 <code>_x</code> 仍会将值绑定到变量，而 <code>_</code> 则完全不会绑定。为了展示这个区别的意义，示例 19-21 会产生一个错误。</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_s) = s {
        println!("found a string");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre>
<p><span class="caption">示例 19-21: 以下划线开头的未使用变量仍然会绑定值，它可能会获取值的所有权</span></p>
<p>我们会得到一个错误，因为 <code>s</code> 的值仍然会移动进 <code>_s</code>，并阻止我们再次使用 <code>s</code>。然而只使用下划线本身，并不会绑定值。示例 19-22 能够无错编译，因为 <code>s</code> 没有被移动进 <code>_</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_) = s {
        println!("found a string");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">示例 19-22: 单独使用下划线不会绑定值</span></p>
<p>上面的代码能很好的运行；因为没有把 <code>s</code> 绑定到任何变量；它没有被移动。</p>
<h4 id="用--忽略剩余值"><a class="header" href="#用--忽略剩余值">用 <code>..</code> 忽略剩余值</a></h4>
<p>对于有多个部分的值，可以使用 <code>..</code> 语法来只使用特定部分并忽略其它值，从而避免不得不每一个忽略值列出下划线。<code>..</code> 模式会忽略模式中剩余的任何没有显式匹配的值部分。在示例 19-23 中，有一个 <code>Point</code> 结构体存放了三维空间中的坐标。在 <code>match</code> 表达式中，我们希望只操作 <code>x</code> 坐标并忽略 <code>y</code> 和 <code>z</code> 字段的值：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!("x is {x}"),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">示例 19-23: 通过使用 <code>..</code> 来忽略 <code>Point</code> 中除 <code>x</code> 以外的字段</span></p>
<p>这里列出了 <code>x</code> 值，接着仅仅包含了 <code>..</code> 模式。这比不得不列出 <code>y: _</code> 和 <code>z: _</code> 要来得简单，特别是在处理有很多字段的结构体，但只涉及一到两个字段时的情形。</p>
<p><code>..</code> 会扩展为所需要的值的数量。示例 19-24 展示了如何在元组中使用 <code>..</code>：</p>
<p><span class="filename">文件名：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!("Some numbers: {first}, {last}");
        }
    }
}</code></pre></pre>
<p><span class="caption">示例 19-24: 只匹配元组中的第一个和最后一个值并忽略掉所有其它值</span></p>
<p>这里用 <code>first</code> 和 <code>last</code> 来匹配第一个和最后一个值。<code>..</code> 将匹配并忽略中间的所有值。</p>
<p>然而使用 <code>..</code> 必须是无歧义的。如果期望匹配和忽略的值是不明确的，Rust 会报错。示例 19-25 展示了一个带有歧义的 <code>..</code> 例子，因此其不能编译：</p>
<p><span class="filename">文件名：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!("Some numbers: {second}")
        },
    }
}</code></pre>
<p><span class="caption">示例 19-25: 尝试以有歧义的方式运用 <code>..</code></span></p>
<p>当编译这个示例时，会得到如下错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>Rust 不可能决定在元组中匹配 <code>second</code> 值之前应该忽略多少个值，以及在之后忽略多少个值。这段代码可能表明我们意在忽略 <code>2</code>，绑定 <code>second</code> 为 <code>4</code>，接着忽略 <code>8</code>、<code>16</code> 和 <code>32</code>；抑或是意在忽略 <code>2</code> 和 <code>4</code>，绑定 <code>second</code> 为 <code>8</code>，接着忽略 <code>16</code> 和 <code>32</code>，以此类推。变量名 <code>second</code> 对于 Rust 来说并没有任何特殊意义，所以会得到编译错误，因为在这两个地方使用 <code>..</code> 是有歧义的。</p>
<h3 id="匹配守卫提供的额外条件"><a class="header" href="#匹配守卫提供的额外条件">匹配守卫提供的额外条件</a></h3>
<p><strong>匹配守卫</strong>（<em>match guard</em>）是一个指定于 <code>match</code> 分支模式之后的额外 <code>if</code> 条件，它也必须被满足才能选择此分支。匹配守卫用于表达比单独的模式所能允许的更为复杂的情况。但是注意，它们仅在 <code>match</code> 表达式中可用，不能用于 <code>if let</code> 或 <code>while let</code> 表达式。</p>
<p>这个条件可以使用模式中创建的变量。示例 19-26 展示了一个 <code>match</code>，其中第一个分支有模式 <code>Some(x)</code> 还有匹配守卫 <code>if x % 2 == 0</code> (当 <code>x</code> 是偶数时为真)：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!("The number {x} is even"),
        Some(x) =&gt; println!("The number {x} is odd"),
        None =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">示例 19-26: 在模式中加入匹配守卫</span></p>
<p>上例会打印出 <code>The number 4 is even</code>。当 <code>num</code> 与模式中第一个分支比较时，因为 <code>Some(4)</code> 匹配 <code>Some(x)</code> 所以可以匹配。接着匹配守卫检查 <code>x</code> 除以 <code>2</code> 的余数是否等于 <code>0</code>，因为它等于 <code>0</code>，所以第一个分支被选择。</p>
<p>相反如果 <code>num</code> 为 <code>Some(5)</code>，因为 <code>5</code> 除以 <code>2</code> 的余数是 <code>1</code> 不等于 <code>0</code> 所以第一个分支的匹配守卫为 <code>false</code>。接着 Rust 会前往第二个分支，这次匹配因为它没有匹配守卫所以会匹配任何 <code>Some</code> 变体。</p>
<p>无法在模式中表达类似 <code>if x % 2 == 0</code> 的条件，所以通过匹配守卫提供了表达类似逻辑的能力。这种替代表达方式的缺点是，编译器不会尝试为包含匹配守卫的模式检查穷尽性。</p>
<p>在示例 19-11 中，我们提到可以使用匹配守卫来解决模式中变量遮蔽的问题，那里 <code>match</code> 表达式的模式中新建了一个变量而不是使用 <code>match</code> 之外的同名变量。新变量意味着不能够测试外部变量的值。示例 19-27 展示了如何使用匹配守卫修复这个问题。</p>
<p><span class="filename">文件名：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(n) if n == y =&gt; println!("Matched, n = {n}"),
        _ =&gt; println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
}</code></pre></pre>
<p><span class="caption">示例 19-27: 使用匹配守卫来测试与外部变量的相等性</span></p>
<p>现在这会打印出 <code>Default case, x = Some(5)</code>。现在第二个匹配分支中的模式不会引入一个遮蔽外部 <code>y</code> 的新变量 <code>y</code>，这意味着可以在匹配守卫中使用外部的 <code>y</code>。相比指定会遮蔽外部 <code>y</code> 的模式 <code>Some(y)</code>，这里指定为 <code>Some(n)</code>。此新建的变量 <code>n</code> 并没有覆盖任何值，因为 <code>match</code> 外部没有变量 <code>n</code>。</p>
<p>匹配守卫 <code>if n == y</code> 并不是一个模式所以没有引入新变量。这个 <code>y</code> <strong>正是</strong>外部的 <code>y</code> 而不是新的遮蔽变量 <code>y</code>，这样就可以通过比较 <code>n</code> 和 <code>y</code> 来表达寻找一个与外部 <code>y</code> 相同的值了。</p>
<p>也可以在匹配守卫中使用<strong>或</strong>运算符 <code>|</code> 来指定多个模式，同时匹配守卫的条件会作用于所有的模式。示例 19-28 展示了结合匹配守卫与使用了 <code>|</code> 的模式的优先级。这个例子中重要的部分是匹配守卫 <code>if y</code> 作用于 <code>4</code>、<code>5</code> <strong>和</strong> <code>6</code>，即使这看起来好像 <code>if y</code> 只作用于 <code>6</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!("yes"),
        _ =&gt; println!("no"),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">示例 19-28: 结合多个模式与匹配守卫</span></p>
<p>这个匹配条件表明此分支值匹配 <code>x</code> 值为 <code>4</code>、<code>5</code> 或 <code>6</code> <strong>同时</strong> <code>y</code> 为 <code>true</code> 的情况。运行这段代码时会发生的是第一个分支的模式因 <code>x</code> 为 <code>4</code> 而匹配，不过匹配守卫 <code>if y</code> 为 <code>false</code>，所以第一个分支不会被选择。代码移动到第二个分支，这会匹配，此程序会打印出 <code>no</code>。这是因为 <code>if</code> 条件作用于整个 <code>4 | 5 | 6</code> 模式，而不仅是最后的值 <code>6</code>。换句话说，匹配守卫与模式的优先级关系看起来像这样：</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>而不是：</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>运行代码后，优先级行为就很明显了：如果匹配守卫只作用于由 <code>|</code> 运算符指定的值列表的最后一个值，这个分支就会匹配且程序会打印出 <code>yes</code>。</p>
<h3 id="-绑定"><a class="header" href="#-绑定"><code>@</code> 绑定</a></h3>
<p><em>at</em> 运算符（<code>@</code>）允许我们在创建一个存放值的变量的同时测试其值是否匹配模式。示例 19-29 展示了一个例子，这里我们希望测试 <code>Message::Hello</code> 的 <code>id</code> 字段是否位于 <code>3..=7</code> 范围内，同时也希望能将其值绑定到 <code>id_variable</code> 变量中以便此分支相关联的代码可以使用它。可以将 <code>id_variable</code> 命名为 <code>id</code>，与字段同名，不过出于示例的目的这里选择了不同的名称。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!("Found an id in range: {id_variable}"),
        Message::Hello { id: 10..=12 } =&gt; {
            println!("Found an id in another range")
        }
        Message::Hello { id } =&gt; println!("Found some other id: {id}"),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">示例 19-29: 使用 <code>@</code> 在模式中绑定值的同时测试它</span></p>
<p>上例会打印出 <code>Found an id in range: 5</code>。通过在 <code>3..=7</code> 之前指定 <code>id_variable @</code>，我们捕获了任何匹配此范围的值并同时测试其值匹配这个范围模式。</p>
<p>第二个分支只在模式中指定了一个范围，分支相关代码没有一个包含 <code>id</code> 字段实际值的变量。<code>id</code> 字段的值可以是 10、11 或 12，不过这个模式的代码并不知情也不能使用 <code>id</code> 字段中的值，因为没有将 <code>id</code> 值保存进一个变量。</p>
<p>最后一个分支指定了一个没有范围的变量，此时确实拥有可以用于分支代码的变量 <code>id</code>。因为这里使用了结构体字段简写语法。不过此分支中没有像头两个分支那样对 <code>id</code> 字段的值进行测试：任何值都会匹配该模式。</p>
<p>使用 <code>@</code> 可以在一个模式中同时测试和保存变量值。</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>模式是 Rust 中一个很有用的功能，它有助于我们区分不同类型的数据。当用于 <code>match</code> 语句时，Rust 确保模式会包含每一个可能的值，否则程序将不能编译。<code>let</code> 语句和函数参数的模式使得这些结构更强大，可以在将值解构为更小部分的同时为变量赋值。可以创建简单或复杂的模式来满足我们的要求。</p>
<p>接下来，在本书倒数第二章中，我们将介绍一些 Rust 众多功能中较为高级的部分。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-02-refutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-00-advanced-features.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-02-refutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-00-advanced-features.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
