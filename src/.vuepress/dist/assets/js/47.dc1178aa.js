(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{223:function(e,t,r){"use strict";r.r(t);var n=r(0),_=Object(n.a)({},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("div",{staticClass:"content"},[e._m(0),e._v(" "),r("blockquote",[r("p",[r("a",{attrs:{href:"https://github.com/rust-lang/book/blob/master/src/ch09-00-error-handling.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("ch09-00-error-handling.md"),r("OutboundLink")],1),e._v(" "),r("br"),e._v("\ncommit 1fedfc4b96c2017f64ecfcf41a0a07e2e815f24f")])]),e._v(" "),r("p",[e._v("Rust 对可靠性的执着也延伸到了错误处理。错误对于软件来说是不可避免的，所以 Rust 有很多特性来处理出现错误的情况。在很多情况下，Rust 要求你承认出错的可能性并在编译代码之前就采取行动。这些要求使得程序更为健壮，它们确保了你会在将代码部署到生产环境之前就发现错误并正确地处理它们！")]),e._v(" "),e._m(1),e._v(" "),e._m(2)])},[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"错误处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#错误处理","aria-hidden":"true"}},[this._v("#")]),this._v(" 错误处理")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("p",[e._v("Rust 将错误组合成两个主要类别："),r("strong",[e._v("可恢复错误")]),e._v("（"),r("em",[e._v("recoverable")]),e._v("）和 "),r("strong",[e._v("不可恢复错误")]),e._v("（"),r("em",[e._v("unrecoverable")]),e._v("）。可恢复错误通常代表向用户报告错误和重试操作是合理的情况，比如未找到文件。不可恢复错误通常是 bug 的同义词，比如尝试访问超过数组结尾的位置。")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("p",[e._v("大部分语言并不区分这两类错误，并采用类似异常这样方式统一处理他们。Rust 并没有异常。相反，对于可恢复错误有 "),r("code",[e._v("Result<T, E>")]),e._v(" 值，以及 "),r("code",[e._v("panic!")]),e._v("，它在遇到不可恢复错误时停止程序执行。这一章会首先介绍 "),r("code",[e._v("panic!")]),e._v(" 调用，接着会讲到如何返回 "),r("code",[e._v("Result<T, E>")]),e._v("。此外，我们将探讨决定是尝试从错误中恢复还是停止执行时的注意事项。")])}],!1,null,null,null);_.options.__file="ch09-00-error-handling.md";t.default=_.exports}}]);