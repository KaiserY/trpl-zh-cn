(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{263:function(t,e,_){"use strict";_.r(e);var v=_(0),i=Object(v.a)({},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("div",{staticClass:"content"},[t._m(0),t._v(" "),_("blockquote",[_("p",[_("a",{attrs:{href:"https://github.com/rust-lang/book/blob/master/second-edition/src/appendix-03-derivable-traits.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("appendix-03-derivable-traits.md"),_("OutboundLink")],1),t._v(" "),_("br"),t._v("\ncommit 32215c1d96c9046c0b553a05fa5ec3ede2e125c3")])]),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),t._m(21),t._v(" "),t._m(22),t._v(" "),t._m(23),t._v(" "),t._m(24),t._v(" "),t._m(25),t._v(" "),t._m(26),t._v(" "),t._m(27),t._v(" "),t._m(28),t._v(" "),t._m(29),t._v(" "),t._m(30),t._v(" "),t._m(31),t._v(" "),t._m(32),t._v(" "),t._m(33),t._v(" "),t._m(34),t._v(" "),t._m(35),t._v(" "),t._m(36),t._v(" "),t._m(37),t._v(" "),t._m(38),t._v(" "),t._m(39),t._v(" "),t._m(40)])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"附录c-可派生的-trait"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#附录c-可派生的-trait","aria-hidden":"true"}},[this._v("#")]),this._v(" 附录C - 可派生的 trait")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在本书的各个部分中，我们讨论了可应用于结构体和枚举的 "),e("code",[this._v("derive")]),this._v(" 属性。"),e("code",[this._v("derive")]),this._v(" 属性生成的代码在使用 "),e("code",[this._v("derive")]),this._v(" 语法注释的类型之上实现了带有默认实现的 trait 。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在该附录中，我们提供标准库中所有可以使用 "),e("code",[this._v("derive")]),this._v(" 的 trait 的参考。每部分都包含：")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[t._v("该 trait 将会派生什么样的操作符和方法")]),t._v(" "),_("li",[t._v("由 "),_("code",[t._v("derive")]),t._v(" 提供什么样的 trait 实现")]),t._v(" "),_("li",[t._v("由什么来实现类型的 trait")]),t._v(" "),_("li",[t._v("是否允许实现该 trait 的条件")]),t._v(" "),_("li",[t._v("需要 trait 操作的例子")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("与 "),e("code",[this._v("derive")]),this._v(" 属性提供的行为相比如果你需要与之不同的行为，请查阅标准库文档以获取每个 trait 的详情，来手动实现它们。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在类型上无法使用 "),e("code",[this._v("derive")]),this._v(" 实现标准库的其余 trait。这些 trait 没有合理的默认行为, 因此，你可以以一种尝试完成的合理方式实现它们。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("一个无法被派生的 trait 的例子是为最终用户处理格式化的 "),e("code",[this._v("Display")]),this._v(" 。你应该时常考虑使用合适的方法来为最终用户显示一个类型。最终用户应该看到类型的什么部分？他们会找出相关部分吗？对他们来说，最相互关联的数据格式是什么样的？Rust 编译器没有这样的洞察力，因此，无法为你提供合适的默认行为。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("本附录所提供的可派生 trait 列表并不全面：库可以为它们自己的 trait 实现 "),e("code",[this._v("derive")]),this._v(" , 让可以使用 "),e("code",[this._v("derive")]),this._v(" 的 trait 列表真诚的开放。实现 "),e("code",[this._v("derive")]),this._v(" 涉及使用程序化宏，这在附录D中有介绍。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"编程人员输出的-debug"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编程人员输出的-debug","aria-hidden":"true"}},[this._v("#")]),this._v(" 编程人员输出的 "),e("code",[this._v("Debug")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("Debug")]),this._v(" trait 在格式化字符串中使调试格式化，你可以在 "),e("code",[this._v("{}")]),this._v(" 占位符里面加上 "),e("code",[this._v(":?")]),this._v(" 显示它。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("Debug")]),this._v(" trait 允许你以调试目的来打印一个类型的实例，因此，使用类型的你以及其他的编程人员可以让程序在执行时在指定点上显示一个实例。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("例如，在使用 "),e("code",[this._v("assert_eq!")]),this._v(" 宏时，Debug` trait 是必须的。如果等式断言失败，这个宏就把给定实例的值作为参数打印出来，因此，编程人员可以看到两个实例为什么不相等。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"等值比较的-partialeq-和-eq"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#等值比较的-partialeq-和-eq","aria-hidden":"true"}},[this._v("#")]),this._v(" 等值比较的 "),e("code",[this._v("PartialEq")]),this._v(" 和 "),e("code",[this._v("Eq")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("PartialEq")]),this._v(" trait 可以比较一个类型的实例以检查是否相等，并且可以使用 "),e("code",[this._v("==")]),this._v(" 和 "),e("code",[this._v("!=")]),this._v(" 操作符。")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[t._v("派生的 "),_("code",[t._v("PartialEq")]),t._v(" 实现了 "),_("code",[t._v("eq")]),t._v(" 方法。当 "),_("code",[t._v("PartialEq")]),t._v(" 在结构体上派生时，只有"),_("em",[t._v("所有")]),t._v("的字段都相等时两个实例才相等，同时只要有字段不相等则两个实例就不相等。当在枚举上派生时，每一个变体(variant)都和它自身相等，且和其他变体都不相等。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("例如，当使用 "),e("code",[this._v("assert_eq!")]),this._v(" 宏时，需要比较比较一个类型的两个实例是否相等，则 "),e("code",[this._v("PartialEq")]),this._v(" trait 是必须的。")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[_("code",[t._v("Eq")]),t._v(" trait 没有方法。其目的是为每一个注解类型的值作标志，其值等于其自身。 "),_("code",[t._v("Eq")]),t._v(" trait 只能应用于那些实现了 "),_("code",[t._v("PartialEq")]),t._v(" 的类型，但并非所有实现了 "),_("code",[t._v("PartialEq")]),t._v(" 的类型可以实现 "),_("code",[t._v("Eq")]),t._v("。浮点类型就是一个例子：浮点数状态的实现，两个非数字（"),_("code",[t._v("NaN")]),t._v("，not-a-number）值是互不相等的。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("例如，对于一个 "),e("code",[this._v("HashMap<K, V>")]),this._v(" 中的 key 来说， "),e("code",[this._v("Eq")]),this._v(" 是必须的，这样 "),e("code",[this._v("HashMap<K, V>")]),this._v(" 就可以知道两个 key 是否一样了。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"次序比较的-partialord-和-ord"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#次序比较的-partialord-和-ord","aria-hidden":"true"}},[this._v("#")]),this._v(" 次序比较的 "),e("code",[this._v("PartialOrd")]),this._v(" 和 "),e("code",[this._v("Ord")])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[_("code",[t._v("PartialOrd")]),t._v(" trait 可以基于排序的目的而比较一个类型的实例。实现了 "),_("code",[t._v("PartialOrd")]),t._v(" 的类型可以使用 "),_("code",[t._v("<")]),t._v("、 "),_("code",[t._v(">")]),t._v("、"),_("code",[t._v("<=")]),t._v(" 和 "),_("code",[t._v(">=")]),t._v(" 操作符。但只能在同时实现了 "),_("code",[t._v("PartialEq")]),t._v(" 的类型上使用 "),_("code",[t._v("PartialOrd")]),t._v("。")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[t._v("派生 "),_("code",[t._v("PartialOrd")]),t._v(" 实现了 "),_("code",[t._v("partial_cmp")]),t._v(" 方法，其返回一个 "),_("code",[t._v("Option<Ordering>")]),t._v(" ，但当给定值无法产生顺序时将返回 "),_("code",[t._v("None")]),t._v("。尽管大多数类型的值都可以比较，但一个无法产生顺序的例子是：浮点类型的非数字值（"),_("code",[t._v("NaN")]),t._v("，not-a-number）。当在浮点数上调用 "),_("code",[t._v("partial_cmp")]),t._v(" 时，"),_("code",[t._v("NaN")]),t._v(" 的浮点数将返回 "),_("code",[t._v("None")]),t._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("当在结构体上派生时，"),e("code",[this._v("PartialOrd")]),this._v(" 以在结构体定义中字段出现的顺序比较每个字段的值来比较两个实例。当在枚举上派生时，认为在枚举定义中声明较早的枚举变体小于其后的变体。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("例如，对于来自于 "),e("code",[this._v("rand")]),this._v(" carte 中的 "),e("code",[this._v("gen_range")]),this._v(" 方法来说，当在一个大值和小值指定的范围内生成一个随机值时，"),e("code",[this._v("PartialOrd")]),this._v(" trait 是必须的。")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[_("code",[t._v("Ord")]),t._v(" trait 也让你明白在一个带注解类型上的任意两个值存在有效顺序。"),_("code",[t._v("Ord")]),t._v(" trait 实现了 "),_("code",[t._v("cmp")]),t._v(" 方法，它返回一个 "),_("code",[t._v("Ordering")]),t._v(" 而不是 "),_("code",[t._v("Option<Ordering>")]),t._v("，因为总存在一个合法的顺序。只可以在实现了 "),_("code",[t._v("PartialOrd")]),t._v(" 和 "),_("code",[t._v("Eq")]),t._v("（ "),_("code",[t._v("Eq")]),t._v(" 依赖 "),_("code",[t._v("PartialEq")]),t._v(" ）的类型上使用 "),_("code",[t._v("Ord")]),t._v(" trait 。当在结构体或枚举上派生时， "),_("code",[t._v("cmp")]),t._v(" 和以 "),_("code",[t._v("PartialOrd")]),t._v(" 派生实现的 "),_("code",[t._v("partial_cmp")]),t._v(" 表现一致。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("例如，当在 "),e("code",[this._v("BTreeSet<T>")]),this._v(" （一种基于有序值存储数据的数据结构）上存值时，"),e("code",[this._v("Ord")]),this._v(" 是必须的。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"复制值的-clone-和-copy"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#复制值的-clone-和-copy","aria-hidden":"true"}},[this._v("#")]),this._v(" 复制值的 "),e("code",[this._v("Clone")]),this._v(" 和 "),e("code",[this._v("Copy")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("Clone")]),this._v(" trait 可以明确地创建一个值的深拷贝（ deep copy ），复制过程可能包含任意代码的执行以及堆上数据的复制。查阅第四章“变量和数据的交互方式：移动”以获取有关 "),e("code",[this._v("Clone")]),this._v(" 的更多信息。")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[t._v("派生 "),_("code",[t._v("Clone")]),t._v(" 实现了 "),_("code",[t._v("clone")]),t._v(" 方法，其为整个的类型实现时，在类型的每一部分上调用了 "),_("code",[t._v("clone")]),t._v(" 方法。这意味着类型中所有字段或值也必须实现 "),_("code",[t._v("Clone")]),t._v(" 来派生 "),_("code",[t._v("Clone")]),t._v(" 。")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[t._v("例如，当在一个切片上调用 "),_("code",[t._v("to_vec")]),t._v(" 方法时，"),_("code",[t._v("Clone")]),t._v(" 是必须的。切片并不拥有其所包含实例的类型，但是从 "),_("code",[t._v("to_vec")]),t._v(" 中返回的 vector 需要拥有其实例，因此，"),_("code",[t._v("to_vec")]),t._v(" 在每个元素上调用 "),_("code",[t._v("clone")]),t._v("。因此，存储在切片中的类型必须实现 "),_("code",[t._v("Clone")]),t._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("Copy")]),this._v(" trait 允许你通过只拷贝存储在栈上的位来复制值而不需要其他代码。查阅第四章“只在栈上的数据：拷贝”的部分来获取有关 "),e("code",[this._v("Copy")]),this._v(" 的更多信息。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("Copy")]),this._v(" trait 并未定义任何方法来阻止编程人员重写这些方法或违反无代码可执行的假设。所以，所有的编程人员可以假设复制一个值非常快。")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[t._v("可以在类型内部全部实现 "),_("code",[t._v("Copy")]),t._v(" trait 的任意类型上派生 "),_("code",[t._v("Copy")]),t._v("。 但只可以在那些同时实现了 "),_("code",[t._v("Clone")]),t._v(" 的类型上使用 "),_("code",[t._v("Copy")]),t._v(" trait ，因为一个实现 "),_("code",[t._v("Copy")]),t._v(" 的类型在尝试实现 "),_("code",[t._v("Clone")]),t._v(" 时执行和 "),_("code",[t._v("Copy")]),t._v(" 相同的任务。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("Copy")]),this._v(" trait 很少使用；实现 "),e("code",[this._v("Copy")]),this._v(" 的类型是可以优化的，这意味着你无需调用 "),e("code",[this._v("clone")]),this._v("，这让代码更简洁。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("使用 "),e("code",[this._v("Clone")]),this._v(" 实现 "),e("code",[this._v("Copy")]),this._v(" 也是有可能的，但代码可能会稍慢或是要使用 "),e("code",[this._v("clone")]),this._v(" 替代。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"固定大小的值到值映射的-hash"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#固定大小的值到值映射的-hash","aria-hidden":"true"}},[this._v("#")]),this._v(" 固定大小的值到值映射的 "),e("code",[this._v("Hash")])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[_("code",[t._v("Hash")]),t._v(" trait 可以实例化一个任意大小的类型，并且能够用哈希（hash）函数将该实例映射到一个固定大小的值上。派生 "),_("code",[t._v("Hash")]),t._v(" 实现了 "),_("code",[t._v("hash")]),t._v(" 方法。"),_("code",[t._v("hash")]),t._v(" 方法的派生实现结合了在类型的每部分调用 "),_("code",[t._v("hash")]),t._v(" 的结果，这意味着所有的字段或值也必须将 "),_("code",[t._v("Hash")]),t._v(" 实现为派生 "),_("code",[t._v("Hash")]),t._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("例如，在 "),e("code",[this._v("HashMap<K, V>")]),this._v(" 的 key 上存储有效数据时，"),e("code",[this._v("Hash")]),this._v(" 是必须的。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"默认值的-default"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#默认值的-default","aria-hidden":"true"}},[this._v("#")]),this._v(" 默认值的 "),e("code",[this._v("Default")])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[_("code",[t._v("Default")]),t._v(" trait 使你创建一个类型的默认值。 派生 "),_("code",[t._v("Default")]),t._v(" 实现了 "),_("code",[t._v("default")]),t._v(" 函数。"),_("code",[t._v("default")]),t._v(" 函数的派生实现调用了类型每部分的 "),_("code",[t._v("default")]),t._v(" 函数，这意味着类型中所有的字段或值也必须把 "),_("code",[t._v("Default")]),t._v(" 实现为派生 "),_("code",[t._v("Default")]),t._v(" 。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("Default::default")]),this._v(" 函数通常结合结构体更新语法一起使用，这在第五章的“使用结构体更新语法从其他实例中创建实例”部分有讨论。可以自定义一个结构体的一小部分字段而剩余字段则使用 "),e("code",[this._v("..Default::default()")]),this._v(" 设置为默认值。")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[t._v("例如，当你在 "),_("code",[t._v("Option<T>")]),t._v(" 实例上使用 "),_("code",[t._v("unwrap_or_default")]),t._v(" 方法时，"),_("code",[t._v("Default")]),t._v(" trait是必须的。如果 "),_("code",[t._v("Option<T>")]),t._v(" 是 "),_("code",[t._v("None")]),t._v("的话, "),_("code",[t._v("unwrap_or_default")]),t._v(" 方法将返回存储在 "),_("code",[t._v("Option<T>")]),t._v(" 中 "),_("code",[t._v("T")]),t._v(" 类型的 "),_("code",[t._v("Default::default")]),t._v(" 的结果。")])}],!1,null,null,null);i.options.__file="appendix-03-derivable-traits.md";e.default=i.exports}}]);