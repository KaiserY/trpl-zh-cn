<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>通过 Deref trait 将智能指针当作常规引用处理</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/assets/css/0.styles.8614bbde.css" as="style"><link rel="preload" href="/assets/js/app.b56e4aff.js" as="script"><link rel="preload" href="/assets/js/79.397902f7.js" as="script"><link rel="prefetch" href="/assets/js/10.d41a3b84.js"><link rel="prefetch" href="/assets/js/100.22ca6861.js"><link rel="prefetch" href="/assets/js/101.80606dd4.js"><link rel="prefetch" href="/assets/js/102.75bf264b.js"><link rel="prefetch" href="/assets/js/103.7615fac4.js"><link rel="prefetch" href="/assets/js/104.a030e309.js"><link rel="prefetch" href="/assets/js/105.ceb5b0f7.js"><link rel="prefetch" href="/assets/js/106.53b25747.js"><link rel="prefetch" href="/assets/js/107.a6f25383.js"><link rel="prefetch" href="/assets/js/108.524846e6.js"><link rel="prefetch" href="/assets/js/109.5b3e8cc8.js"><link rel="prefetch" href="/assets/js/11.7f9bf643.js"><link rel="prefetch" href="/assets/js/110.a106958d.js"><link rel="prefetch" href="/assets/js/111.b1600e65.js"><link rel="prefetch" href="/assets/js/112.81bf40f0.js"><link rel="prefetch" href="/assets/js/12.c7e4d9a8.js"><link rel="prefetch" href="/assets/js/13.235bc06a.js"><link rel="prefetch" href="/assets/js/14.8b8a21b7.js"><link rel="prefetch" href="/assets/js/15.83a607fc.js"><link rel="prefetch" href="/assets/js/16.2bf746d6.js"><link rel="prefetch" href="/assets/js/17.36a5d5f3.js"><link rel="prefetch" href="/assets/js/18.82e00fba.js"><link rel="prefetch" href="/assets/js/19.1c2116c8.js"><link rel="prefetch" href="/assets/js/2.3505b190.js"><link rel="prefetch" href="/assets/js/20.1f4e3d0f.js"><link rel="prefetch" href="/assets/js/21.80dca6df.js"><link rel="prefetch" href="/assets/js/22.24977f4c.js"><link rel="prefetch" href="/assets/js/23.867b53ea.js"><link rel="prefetch" href="/assets/js/24.d59d9203.js"><link rel="prefetch" href="/assets/js/25.fae2b839.js"><link rel="prefetch" href="/assets/js/26.ba769edc.js"><link rel="prefetch" href="/assets/js/27.03216770.js"><link rel="prefetch" href="/assets/js/28.82b934bf.js"><link rel="prefetch" href="/assets/js/29.9bbe7e55.js"><link rel="prefetch" href="/assets/js/3.ba62e17c.js"><link rel="prefetch" href="/assets/js/30.ed75778f.js"><link rel="prefetch" href="/assets/js/31.247a3dbb.js"><link rel="prefetch" href="/assets/js/32.b1bb1e43.js"><link rel="prefetch" href="/assets/js/33.3656c740.js"><link rel="prefetch" href="/assets/js/34.03c1b47c.js"><link rel="prefetch" href="/assets/js/35.5af5d342.js"><link rel="prefetch" href="/assets/js/36.572a9496.js"><link rel="prefetch" href="/assets/js/37.319db1b7.js"><link rel="prefetch" href="/assets/js/38.19837e80.js"><link rel="prefetch" href="/assets/js/39.72675c02.js"><link rel="prefetch" href="/assets/js/4.f9a0ae28.js"><link rel="prefetch" href="/assets/js/40.d9f81c69.js"><link rel="prefetch" href="/assets/js/41.184751dc.js"><link rel="prefetch" href="/assets/js/42.9fa6eee5.js"><link rel="prefetch" href="/assets/js/43.b3333fb7.js"><link rel="prefetch" href="/assets/js/44.97c13303.js"><link rel="prefetch" href="/assets/js/45.8afb63d1.js"><link rel="prefetch" href="/assets/js/46.ac497cb6.js"><link rel="prefetch" href="/assets/js/47.dc1178aa.js"><link rel="prefetch" href="/assets/js/48.50b8e29c.js"><link rel="prefetch" href="/assets/js/49.385dc110.js"><link rel="prefetch" href="/assets/js/5.0204093a.js"><link rel="prefetch" href="/assets/js/50.cadce2ee.js"><link rel="prefetch" href="/assets/js/51.d4e57e23.js"><link rel="prefetch" href="/assets/js/52.323a010e.js"><link rel="prefetch" href="/assets/js/53.377c0582.js"><link rel="prefetch" href="/assets/js/54.8d06b2c9.js"><link rel="prefetch" href="/assets/js/55.f82d7ef0.js"><link rel="prefetch" href="/assets/js/56.c9db2b25.js"><link rel="prefetch" href="/assets/js/57.bc11287b.js"><link rel="prefetch" href="/assets/js/58.a1a44552.js"><link rel="prefetch" href="/assets/js/59.4afc94b7.js"><link rel="prefetch" href="/assets/js/6.4774d695.js"><link rel="prefetch" href="/assets/js/60.867aed26.js"><link rel="prefetch" href="/assets/js/61.74327fa7.js"><link rel="prefetch" href="/assets/js/62.177c0b30.js"><link rel="prefetch" href="/assets/js/63.3e0d51da.js"><link rel="prefetch" href="/assets/js/64.e8778b11.js"><link rel="prefetch" href="/assets/js/65.b0dde85a.js"><link rel="prefetch" href="/assets/js/66.3bba1132.js"><link rel="prefetch" href="/assets/js/67.fb2ec2e1.js"><link rel="prefetch" href="/assets/js/68.d8ef845b.js"><link rel="prefetch" href="/assets/js/69.5b80f65b.js"><link rel="prefetch" href="/assets/js/7.010146f6.js"><link rel="prefetch" href="/assets/js/70.e265a8a0.js"><link rel="prefetch" href="/assets/js/71.08e24461.js"><link rel="prefetch" href="/assets/js/72.9f1ed203.js"><link rel="prefetch" href="/assets/js/73.cf073a90.js"><link rel="prefetch" href="/assets/js/74.e5e6cb7a.js"><link rel="prefetch" href="/assets/js/75.12d311a9.js"><link rel="prefetch" href="/assets/js/76.27ceea65.js"><link rel="prefetch" href="/assets/js/77.2d04e2fc.js"><link rel="prefetch" href="/assets/js/78.cd7b5394.js"><link rel="prefetch" href="/assets/js/8.de3fc0db.js"><link rel="prefetch" href="/assets/js/80.8f355347.js"><link rel="prefetch" href="/assets/js/81.9fcee337.js"><link rel="prefetch" href="/assets/js/82.67857b15.js"><link rel="prefetch" href="/assets/js/83.8638b011.js"><link rel="prefetch" href="/assets/js/84.77ee6a86.js"><link rel="prefetch" href="/assets/js/85.724ec824.js"><link rel="prefetch" href="/assets/js/86.e0caf86b.js"><link rel="prefetch" href="/assets/js/87.32cc9faa.js"><link rel="prefetch" href="/assets/js/88.8db036d0.js"><link rel="prefetch" href="/assets/js/89.63be6804.js"><link rel="prefetch" href="/assets/js/9.a240a747.js"><link rel="prefetch" href="/assets/js/90.23557c83.js"><link rel="prefetch" href="/assets/js/91.0fc26ad3.js"><link rel="prefetch" href="/assets/js/92.45cce200.js"><link rel="prefetch" href="/assets/js/93.2a7d9b35.js"><link rel="prefetch" href="/assets/js/94.25f7b020.js"><link rel="prefetch" href="/assets/js/95.3d28b93b.js"><link rel="prefetch" href="/assets/js/96.fb907808.js"><link rel="prefetch" href="/assets/js/97.e4875071.js"><link rel="prefetch" href="/assets/js/98.2859c908.js"><link rel="prefetch" href="/assets/js/99.ac5b7b90.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8614bbde.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><!---->  <!----> </div> <div class="page"> <div class="content"><h2 id="通过-deref-trait-将智能指针当作常规引用处理"><a href="#通过-deref-trait-将智能指针当作常规引用处理" aria-hidden="true" class="header-anchor">#</a> 通过 <code>Deref</code> trait 将智能指针当作常规引用处理</h2> <blockquote><p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch15-02-deref.md" target="_blank" rel="noopener noreferrer">ch15-02-deref.md<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <br>
commit d06a6a181fd61704cbf7feb55bc61d518c6469f9</p></blockquote> <p>实现 <code>Deref</code> trait 允许我们重载 <strong>解引用运算符</strong>（<em>dereference operator</em>）<code>*</code>（与乘法运算符或 glob 运算符相区别）。通过这种方式实现 <code>Deref</code> trait 可以被当作常规引用来对待，可以编写操作引用的代码并用于智能指针。</p> <p>让我们首先看看 <code>*</code> 如何处理引用，接着尝试定义我们自己的类 <code>Box&lt;T&gt;</code> 类型并看看为何 <code>*</code> 不能像引用一样工作。我们会探索如何实现 <code>Deref</code> trait 使得智能指针以类似引用的方式工作变为可能。最后，我们会讨论 Rust 的 <strong>解引用强制多态</strong>（<em>deref coercions</em>）功能和它是如何一同处理引用或智能指针的。</p> <h3 id="通过-追踪指针的值"><a href="#通过-追踪指针的值" aria-hidden="true" class="header-anchor">#</a> 通过 <code>*</code> 追踪指针的值</h3> <p>常规引用是一个指针类型，一种理解指针的方式是将其看成指向储存在其他某处值的箭头。在示例 15-8 中，创建了一个 <code>i32</code> 值的引用接着使用解引用运算符来跟踪所引用的数据：</p> <p><span class="filename">文件名: src/main.rs</span></p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>

    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><span class="caption">示例 15-8：使用解引用运算符来跟踪 <code>i32</code> 值的引用</span></p> <p>变量 <code>x</code> 存放了一个 <code>i32</code> 值 <code>5</code>。<code>y</code> 等于 <code>x</code> 的一个引用。可以断言 <code>x</code> 等于 <code>5</code>。然而，如果希望对 <code>y</code> 的值做出断言，必须使用 <code>*y</code> 来追踪引用所指向的值（也就是 <strong>解引用</strong>）。一旦解引用了 <code>y</code>，就可以访问 <code>y</code> 所指向的整型值并可以与 <code>5</code> 做比较。</p> <p>相反如果尝试编写 <code>assert_eq!(5, y);</code>，则会得到如下编译错误：</p> <div class="language-text extra-class"><pre class="language-text"><code>error[E0277]: the trait bound `{integer}: std::cmp::PartialEq&lt;&amp;{integer}&gt;` is
not satisfied
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ can't compare `{integer}` with `&amp;{integer}`
  |
  = help: the trait `std::cmp::PartialEq&lt;&amp;{integer}&gt;` is not implemented for
  `{integer}`
</code></pre></div><p>不允许比较数字的引用与数字，因为它们是不同的类型。必须使用 <code>*</code> 追踪引用所指向的值。</p> <h3 id="像引用一样使用-box-t"><a href="#像引用一样使用-box-t" aria-hidden="true" class="header-anchor">#</a> 像引用一样使用 <code>Box&lt;T&gt;</code></h3> <p>可以重写示例 15-8 中的代码，使用 <code>Box&lt;T&gt;</code> 来代替引用，解引用运算符也一样能工作，如示例 15-9 所示：</p> <p><span class="filename">文件名: src/main.rs</span></p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><span class="caption">示例 15-9：在 <code>Box&lt;i32&gt;</code> 上使用解引用运算符</span></p> <p>相比示例 15-8 唯一修改的地方就是将 <code>y</code> 设置为一个指向 <code>x</code> 值的 box 实例，而不是指向 <code>x</code> 值的引用。在最后的断言中，可以使用解引用运算符以 <code>y</code> 为引用时相同的方式追踪 box 的指针。让我们通过实现自己的 box 类型来探索 <code>Box&lt;T&gt;</code> 能这么做有何特殊之处。</p> <h3 id="自定义智能指针"><a href="#自定义智能指针" aria-hidden="true" class="header-anchor">#</a> 自定义智能指针</h3> <p>为了体会默认智能指针的行为不同于引用，让我们创建一个类似于标准库提供的 <code>Box&lt;T&gt;</code> 类型的智能指针。接着会学习如何增加使用解引用运算符的功能。</p> <p>从根本上说，<code>Box&lt;T&gt;</code> 被定义为包含一个元素的元组结构体，所以示例 15-10 以相同的方式定义了 <code>MyBox&lt;T&gt;</code> 类型。我们还定义了 <code>new</code> 函数来对应定义于 <code>Box&lt;T&gt;</code> 的 <code>new</code> 函数：</p> <p><span class="filename">文件名: src/main.rs</span></p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">struct</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">MyBox</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><span class="caption">示例 15-10：定义 <code>MyBox&lt;T&gt;</code> 类型</span></p> <p>这里定义了一个结构体 <code>MyBox</code> 并声明了一个泛型 <code>T</code>，因为我们希望其可以存放任何类型的值。<code>MyBox</code> 是一个包含 <code>T</code> 类型元素的元组结构体。<code>MyBox::new</code> 函数获取一个 <code>T</code> 类型的参数并返回一个存放传入值的 <code>MyBox</code> 实例。</p> <p>尝试将示例 15-9 中的代码加入示例 15-10 中并修改 <code>main</code> 使用我们定义的 <code>MyBox&lt;T&gt;</code> 类型代替 <code>Box&lt;T&gt;</code>。示例 15-11 中的代码不能编译，因为 Rust 不知道如何解引用 <code>MyBox</code>：</p> <p><span class="filename">文件名: src/main.rs</span></p> <div class="language-rust,ignore extra-class"><pre class="language-text"><code>fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></div><p><span class="caption">示例 15-11：尝试以使用引用和 <code>Box&lt;T&gt;</code> 相同的方式使用 <code>MyBox&lt;T&gt;</code></span></p> <p>得到的编译错误是：</p> <div class="language-text extra-class"><pre class="language-text"><code>error: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^
</code></pre></div><p><code>MyBox&lt;T&gt;</code> 类型不能解引用我们并没有为其实现这个功能。为了启用 <code>*</code> 运算符的解引用功能，可以实现 <code>Deref</code> trait。</p> <h3 id="实现-deref-trait-定义如何像引用一样对待某类型"><a href="#实现-deref-trait-定义如何像引用一样对待某类型" aria-hidden="true" class="header-anchor">#</a> 实现 <code>Deref</code> trait 定义如何像引用一样对待某类型</h3> <p>如第十章所讨论的，为了实现 trait，需要提供 trait 所需的方法实现。<code>Deref</code> trait，由标准库提供，要求实现名为 <code>deref</code> 的方法，其借用 <code>self</code> 并返回一个内部数据的引用。示例 15-12 包含定义于 <code>MyBox</code> 之上的 <code>Deref</code> 实现：</p> <p><span class="filename">文件名: src/main.rs</span></p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>ops<span class="token punctuation">:</span><span class="token punctuation">:</span>Deref<span class="token punctuation">;</span>

# <span class="token keyword">struct</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Deref <span class="token keyword">for</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Target <span class="token operator">=</span> T<span class="token punctuation">;</span>

    <span class="token keyword">fn</span> <span class="token function">deref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span>T <span class="token punctuation">{</span>
        <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><span class="caption">示例 15-12：<code>MyBox&lt;T&gt;</code> 上的 <code>Deref</code> 实现</span></p> <p><code>type Target = T;</code> 语法定义了用于此 trait 的关联类型。关联类型是一个稍有不同的定义泛型参数的方式，现在还无需过多的担心它；第十九章会详细介绍。</p> <p><code>deref</code> 方法体中写入了 <code>&amp;self.0</code>，这样 <code>deref</code> 返回了我希望通过 <code>*</code> 运算符访问的值的引用。示例 15-11 中的 <code>main</code> 函数中对 <code>MyBox&lt;T&gt;</code> 值的 <code>*</code> 调用现在可以编译并能通过断言了！</p> <p>没有 <code>Deref</code> trait 的话，编译器可以解引用的只有 <code>&amp;</code> 引用类型；有了 <code>Deref</code> trait 之后，对任何实现 <code>Deref</code> trait 的类型，编译器都能（通过解引用的形式）从其获取一个值。只要调用这个类型的 <code>deref</code> 方法，编译器就可以得到一个 <code>&amp;</code> 引用，再对 <code>&amp;</code> 引用进行解引用对它来说就是熟悉的操作了。</p> <p>当我们在示例 15-11 中输入 <code>*y</code> 时，Rust 事实上在底层运行了如下代码：</p> <div class="language-rust,ignore extra-class"><pre class="language-text"><code>*(y.deref())
</code></pre></div> <p>Rust 将 <code>*</code> 运算符替换为先调用 <code>deref</code> 方法再进行直接引用的操作，如此我们便不用担心是不是还需要手动调用 <code>deref</code> 方法了。Rust 的这个特性可以让我们写出行为一致的代码，无论是面对的是常规引用还是实现了 <code>Deref</code> 的类型。</p> <p><code>deref</code> 方法返回值的引用，以及 <code>*(y.deref())</code> 括号外边的普通解引用仍为必须的原因在于所有权。如果 <code>deref</code> 方法直接返回值而不是值的引用，其值（的所有权）将被移出 <code>self</code>。在这里以及大部分使用解引用运算符的情况下我们并不希望获取 <code>MyBox&lt;T&gt;</code> 内部值的所有权。</p> <p>注意，每次当我们在代码中使用 <code>*</code> 时， <code>*</code> 运算符都被替换成了先调用 <code>deref</code> 方法再接着使用 <code>*</code> 解引用的操作，且只会发生一次，不会对 <code>*</code> 操作符无限递归替换，解引用出上面 <code>i32</code> 类型的值就停止了，这个值与示例 15-11 中 <code>assert_eq!</code> 的 <code>5</code> 相匹配。</p> <h3 id="函数和方法的隐式解引用强制多态"><a href="#函数和方法的隐式解引用强制多态" aria-hidden="true" class="header-anchor">#</a> 函数和方法的隐式解引用强制多态</h3> <p><strong>解引用强制多态</strong>（<em>deref coercions</em>）是 Rust 表现在函数或方法传参上的一种便利。其将实现了 <code>Deref</code> 的类型的引用转换为原始类型通过 <code>Deref</code> 所能够转换的类型的引用。当这种特定类型的引用作为实参传递给和形参类型不同的函数或方法时，解引用强制多态将自动发生。这时会有一系列的 <code>deref</code> 方法被调用，把我们提供的类型转换成了参数所需的类型。</p> <p>解引用强制多态的加入使得 Rust 程序员编写函数和方法调用时无需增加过多显式使用 <code>&amp;</code> 和 <code>*</code> 的引用和解引用。这个功能也使得我们可以编写更多同时作用于引用或智能指针的代码。</p> <p>作为展示解引用强制多态的实例，让我们使用示例 15-10 中定义的 <code>MyBox&lt;T&gt;</code>，以及示例 15-12 中增加的 <code>Deref</code> 实现。示例 15-13 展示了一个有着字符串 slice 参数的函数定义：</p> <p><span class="filename">文件名: src/main.rs</span></p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">hello</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, {}!&quot;</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><span class="caption">示例 15-13：<code>hello</code> 函数有着 <code>&amp;str</code> 类型的参数 <code>name</code></span></p> <p>可以使用字符串 slice 作为参数调用 <code>hello</code> 函数，比如 <code>hello(&quot;Rust&quot;);</code>。解引用强制多态使得用 <code>MyBox&lt;String&gt;</code> 类型值的引用调用 <code>hello</code> 成为可能，如示例 15-14 所示：</p> <p><span class="filename">文件名: src/main.rs</span></p> <div class="language-rust extra-class"><pre class="language-rust"><code># <span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>ops<span class="token punctuation">:</span><span class="token punctuation">:</span>Deref<span class="token punctuation">;</span>
#
# <span class="token keyword">struct</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>
#
# <span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
#     <span class="token keyword">fn</span> <span class="token function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
#         <span class="token function">MyBox</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
#     <span class="token punctuation">}</span>
# <span class="token punctuation">}</span>
#
# <span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Deref <span class="token keyword">for</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
#     <span class="token keyword">type</span> Target <span class="token operator">=</span> T<span class="token punctuation">;</span>
#
#     <span class="token keyword">fn</span> <span class="token function">deref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span>T <span class="token punctuation">{</span>
#         <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span>
#     <span class="token punctuation">}</span>
# <span class="token punctuation">}</span>
#
# <span class="token keyword">fn</span> <span class="token function">hello</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
#     <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, {}!&quot;</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
# <span class="token punctuation">}</span>
#
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> m <span class="token operator">=</span> MyBox<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Rust&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">hello</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><span class="caption">示例 15-14：因为解引用强制多态，使用 <code>MyBox&lt;String&gt;</code> 的引用调用 <code>hello</code> 是可行的</span></p> <p>这里使用 <code>&amp;m</code> 调用 <code>hello</code> 函数，其为 <code>MyBox&lt;String&gt;</code> 值的引用。因为示例 15-12 中在 <code>MyBox&lt;T&gt;</code> 上实现了 <code>Deref</code> trait，Rust 可以通过 <code>deref</code> 调用将 <code>&amp;MyBox&lt;String&gt;</code> 变为 <code>&amp;String</code>。标准库中提供了 <code>String</code> 上的 <code>Deref</code> 实现，其会返回字符串 slice，这可以在 <code>Deref</code> 的 API 文档中看到。Rust 再次调用 <code>deref</code> 将 <code>&amp;String</code> 变为 <code>&amp;str</code>，这就符合 <code>hello</code> 函数的定义了。</p> <p>如果 Rust 没有实现解引用强制多态，为了使用 <code>&amp;MyBox&lt;String&gt;</code> 类型的值调用 <code>hello</code>，则不得不编写示例 15-15 中的代码来代替示例 15-14：</p> <p><span class="filename">文件名: src/main.rs</span></p> <div class="language-rust extra-class"><pre class="language-rust"><code># <span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>ops<span class="token punctuation">:</span><span class="token punctuation">:</span>Deref<span class="token punctuation">;</span>
#
# <span class="token keyword">struct</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>
#
# <span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
#     <span class="token keyword">fn</span> <span class="token function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
#         <span class="token function">MyBox</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
#     <span class="token punctuation">}</span>
# <span class="token punctuation">}</span>
#
# <span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Deref <span class="token keyword">for</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
#     <span class="token keyword">type</span> Target <span class="token operator">=</span> T<span class="token punctuation">;</span>
#
#     <span class="token keyword">fn</span> <span class="token function">deref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span>T <span class="token punctuation">{</span>
#         <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span>
#     <span class="token punctuation">}</span>
# <span class="token punctuation">}</span>
#
# <span class="token keyword">fn</span> <span class="token function">hello</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
#     <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, {}!&quot;</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
# <span class="token punctuation">}</span>
#
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> m <span class="token operator">=</span> MyBox<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Rust&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">hello</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><span class="caption">示例 15-15：如果 Rust 没有解引用强制多态则必须编写的代码</span></p> <p><code>(*m)</code> 将 <code>MyBox&lt;String&gt;</code> 解引用为 <code>String</code>。接着 <code>&amp;</code> 和 <code>[..]</code> 获取了整个 <code>String</code> 的字符串 slice 来匹配 <code>hello</code> 的签名。没有解引用强制多态所有这些符号混在一起将更难以读写和理解。解引用强制多态使得 Rust 自动的帮我们处理这些转换。</p> <p>当所涉及到的类型定义了 <code>Deref</code> trait，Rust 会分析这些类型并使用任意多次 <code>Deref::deref</code> 调用以获得匹配参数的类型。这些解析都发生在编译时，所以利用解引用强制多态并没有运行时惩罚！</p> <h3 id="解引用强制多态如何与可变性交互"><a href="#解引用强制多态如何与可变性交互" aria-hidden="true" class="header-anchor">#</a> 解引用强制多态如何与可变性交互</h3> <p>类似于如何使用 <code>Deref</code> trait 重载不可变引用的 <code>*</code> 运算符，Rust 提供了 <code>DerefMut</code> trait 用于重载可变引用的 <code>*</code> 运算符。</p> <p>Rust 在发现类型和 trait 实现满足三种情况时会进行解引用强制多态：</p> <ul><li>当 <code>T: Deref&lt;Target=U&gt;</code> 时从 <code>&amp;T</code> 到 <code>&amp;U</code>。</li> <li>当 <code>T: DerefMut&lt;Target=U&gt;</code> 时从 <code>&amp;mut T</code> 到 <code>&amp;mut U</code>。</li> <li>当 <code>T: Deref&lt;Target=U&gt;</code> 时从 <code>&amp;mut T</code> 到 <code>&amp;U</code>。</li></ul> <p>头两个情况除了可变性之外是相同的：第一种情况表明如果有一个 <code>&amp;T</code>，而 <code>T</code> 实现了返回 <code>U</code> 类型的 <code>Deref</code>，则可以直接得到 <code>&amp;U</code>。第二种情况表明对于可变引用也有着相同的行为。</p> <p>最后一个情况有些微妙：Rust 也会将可变引用强转为不可变引用。但是反之是 <strong>不可能</strong> 的：不可变引用永远也不能强转为可变引用。因为根据借用规则，如果有一个可变引用，其必须是这些数据的唯一引用（否则程序将无法编译）。将一个可变引用转换为不可变引用永远也不会打破借用规则。将不可变引用转换为可变引用则需要数据只能有一个不可变引用，而借用规则无法保证这一点。因此，Rust 无法假设将不可变引用转换为可变引用是可能的。</p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/79.397902f7.js" defer></script><script src="/assets/js/app.b56e4aff.js" defer></script>
  </body>
</html>
