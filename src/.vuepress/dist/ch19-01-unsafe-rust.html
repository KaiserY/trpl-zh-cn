<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>不安全 Rust</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/assets/css/0.styles.8614bbde.css" as="style"><link rel="preload" href="/assets/js/app.b56e4aff.js" as="script"><link rel="preload" href="/assets/js/98.2859c908.js" as="script"><link rel="prefetch" href="/assets/js/10.d41a3b84.js"><link rel="prefetch" href="/assets/js/100.22ca6861.js"><link rel="prefetch" href="/assets/js/101.80606dd4.js"><link rel="prefetch" href="/assets/js/102.75bf264b.js"><link rel="prefetch" href="/assets/js/103.7615fac4.js"><link rel="prefetch" href="/assets/js/104.a030e309.js"><link rel="prefetch" href="/assets/js/105.ceb5b0f7.js"><link rel="prefetch" href="/assets/js/106.53b25747.js"><link rel="prefetch" href="/assets/js/107.a6f25383.js"><link rel="prefetch" href="/assets/js/108.524846e6.js"><link rel="prefetch" href="/assets/js/109.5b3e8cc8.js"><link rel="prefetch" href="/assets/js/11.7f9bf643.js"><link rel="prefetch" href="/assets/js/110.a106958d.js"><link rel="prefetch" href="/assets/js/111.b1600e65.js"><link rel="prefetch" href="/assets/js/112.81bf40f0.js"><link rel="prefetch" href="/assets/js/12.c7e4d9a8.js"><link rel="prefetch" href="/assets/js/13.235bc06a.js"><link rel="prefetch" href="/assets/js/14.8b8a21b7.js"><link rel="prefetch" href="/assets/js/15.83a607fc.js"><link rel="prefetch" href="/assets/js/16.2bf746d6.js"><link rel="prefetch" href="/assets/js/17.36a5d5f3.js"><link rel="prefetch" href="/assets/js/18.82e00fba.js"><link rel="prefetch" href="/assets/js/19.1c2116c8.js"><link rel="prefetch" href="/assets/js/2.3505b190.js"><link rel="prefetch" href="/assets/js/20.1f4e3d0f.js"><link rel="prefetch" href="/assets/js/21.80dca6df.js"><link rel="prefetch" href="/assets/js/22.24977f4c.js"><link rel="prefetch" href="/assets/js/23.867b53ea.js"><link rel="prefetch" href="/assets/js/24.d59d9203.js"><link rel="prefetch" href="/assets/js/25.fae2b839.js"><link rel="prefetch" href="/assets/js/26.ba769edc.js"><link rel="prefetch" href="/assets/js/27.03216770.js"><link rel="prefetch" href="/assets/js/28.82b934bf.js"><link rel="prefetch" href="/assets/js/29.9bbe7e55.js"><link rel="prefetch" href="/assets/js/3.ba62e17c.js"><link rel="prefetch" href="/assets/js/30.ed75778f.js"><link rel="prefetch" href="/assets/js/31.247a3dbb.js"><link rel="prefetch" href="/assets/js/32.b1bb1e43.js"><link rel="prefetch" href="/assets/js/33.3656c740.js"><link rel="prefetch" href="/assets/js/34.03c1b47c.js"><link rel="prefetch" href="/assets/js/35.5af5d342.js"><link rel="prefetch" href="/assets/js/36.572a9496.js"><link rel="prefetch" href="/assets/js/37.319db1b7.js"><link rel="prefetch" href="/assets/js/38.19837e80.js"><link rel="prefetch" href="/assets/js/39.72675c02.js"><link rel="prefetch" href="/assets/js/4.f9a0ae28.js"><link rel="prefetch" href="/assets/js/40.d9f81c69.js"><link rel="prefetch" href="/assets/js/41.184751dc.js"><link rel="prefetch" href="/assets/js/42.9fa6eee5.js"><link rel="prefetch" href="/assets/js/43.b3333fb7.js"><link rel="prefetch" href="/assets/js/44.97c13303.js"><link rel="prefetch" href="/assets/js/45.8afb63d1.js"><link rel="prefetch" href="/assets/js/46.ac497cb6.js"><link rel="prefetch" href="/assets/js/47.dc1178aa.js"><link rel="prefetch" href="/assets/js/48.50b8e29c.js"><link rel="prefetch" href="/assets/js/49.385dc110.js"><link rel="prefetch" href="/assets/js/5.0204093a.js"><link rel="prefetch" href="/assets/js/50.cadce2ee.js"><link rel="prefetch" href="/assets/js/51.d4e57e23.js"><link rel="prefetch" href="/assets/js/52.323a010e.js"><link rel="prefetch" href="/assets/js/53.377c0582.js"><link rel="prefetch" href="/assets/js/54.8d06b2c9.js"><link rel="prefetch" href="/assets/js/55.f82d7ef0.js"><link rel="prefetch" href="/assets/js/56.c9db2b25.js"><link rel="prefetch" href="/assets/js/57.bc11287b.js"><link rel="prefetch" href="/assets/js/58.a1a44552.js"><link rel="prefetch" href="/assets/js/59.4afc94b7.js"><link rel="prefetch" href="/assets/js/6.4774d695.js"><link rel="prefetch" href="/assets/js/60.867aed26.js"><link rel="prefetch" href="/assets/js/61.74327fa7.js"><link rel="prefetch" href="/assets/js/62.177c0b30.js"><link rel="prefetch" href="/assets/js/63.3e0d51da.js"><link rel="prefetch" href="/assets/js/64.e8778b11.js"><link rel="prefetch" href="/assets/js/65.b0dde85a.js"><link rel="prefetch" href="/assets/js/66.3bba1132.js"><link rel="prefetch" href="/assets/js/67.fb2ec2e1.js"><link rel="prefetch" href="/assets/js/68.d8ef845b.js"><link rel="prefetch" href="/assets/js/69.5b80f65b.js"><link rel="prefetch" href="/assets/js/7.010146f6.js"><link rel="prefetch" href="/assets/js/70.e265a8a0.js"><link rel="prefetch" href="/assets/js/71.08e24461.js"><link rel="prefetch" href="/assets/js/72.9f1ed203.js"><link rel="prefetch" href="/assets/js/73.cf073a90.js"><link rel="prefetch" href="/assets/js/74.e5e6cb7a.js"><link rel="prefetch" href="/assets/js/75.12d311a9.js"><link rel="prefetch" href="/assets/js/76.27ceea65.js"><link rel="prefetch" href="/assets/js/77.2d04e2fc.js"><link rel="prefetch" href="/assets/js/78.cd7b5394.js"><link rel="prefetch" href="/assets/js/79.397902f7.js"><link rel="prefetch" href="/assets/js/8.de3fc0db.js"><link rel="prefetch" href="/assets/js/80.8f355347.js"><link rel="prefetch" href="/assets/js/81.9fcee337.js"><link rel="prefetch" href="/assets/js/82.67857b15.js"><link rel="prefetch" href="/assets/js/83.8638b011.js"><link rel="prefetch" href="/assets/js/84.77ee6a86.js"><link rel="prefetch" href="/assets/js/85.724ec824.js"><link rel="prefetch" href="/assets/js/86.e0caf86b.js"><link rel="prefetch" href="/assets/js/87.32cc9faa.js"><link rel="prefetch" href="/assets/js/88.8db036d0.js"><link rel="prefetch" href="/assets/js/89.63be6804.js"><link rel="prefetch" href="/assets/js/9.a240a747.js"><link rel="prefetch" href="/assets/js/90.23557c83.js"><link rel="prefetch" href="/assets/js/91.0fc26ad3.js"><link rel="prefetch" href="/assets/js/92.45cce200.js"><link rel="prefetch" href="/assets/js/93.2a7d9b35.js"><link rel="prefetch" href="/assets/js/94.25f7b020.js"><link rel="prefetch" href="/assets/js/95.3d28b93b.js"><link rel="prefetch" href="/assets/js/96.fb907808.js"><link rel="prefetch" href="/assets/js/97.e4875071.js"><link rel="prefetch" href="/assets/js/99.ac5b7b90.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8614bbde.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><!---->  <!----> </div> <div class="page"> <div class="content"><h2 id="不安全-rust"><a href="#不安全-rust" aria-hidden="true" class="header-anchor">#</a> 不安全 Rust</h2> <blockquote><p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch19-01-unsafe-rust.md" target="_blank" rel="noopener noreferrer">ch19-01-unsafe-rust.md<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <br>
commit c2b43bd978a9176ac9aba22595e33d2335b2d04b</p></blockquote> <p>目前为止讨论过的代码都有 Rust 在编译时会强制执行的内存安全保证。然而，Rust 还隐藏有第二种语言，它不会强制执行这类内存安全保证：不安全 Rust。它与常规 Rust 代码无异，但是会提供额外的超级力量。</p> <p>不安全 Rust 之所以存在，是因为静态分析本质上是保守的。当编译器尝试确定一段代码是否支持某个保证时，拒绝一些有效的程序比接受无效程序要好一些。这必然意味着有时代码可能是合法的，但是 Rust 不这么认为！在这种情况下，可以使用不安全代码告诉编译器，“相信我，我知道我在干什么。”这么做的缺点就是你只能靠自己了：如果不安全代码出错了，比如解引用空指针，可能会导致不安全的内存使用。</p> <p>另一个 Rust 存在不安全一面的原因是：底层计算机硬件固有的不安全性。如果 Rust 不允许进行不安全操作，那么有些任务则根本完成不了。Rust 需要能够进行像直接与操作系统交互，甚至于编写你自己的操作系统这样的底层系统编程！这也是 Rust 语言的目标之一。让我们看看不安全 Rust 能做什么，和怎么做。</p> <h3 id="不安全的超级力量"><a href="#不安全的超级力量" aria-hidden="true" class="header-anchor">#</a> 不安全的超级力量</h3> <p>可以通过 <code>unsafe</code> 关键字来切换到不安全 Rust，接着可以开启一个新的存放不安全代码的块。这里有四类可以在不安全 Rust 中进行而不能用于安全 Rust 的操作。称之为 “不安全的超级力量。”这些超级力量是：</p> <ol><li>解引用裸指针</li> <li>调用不安全的函数或方法</li> <li>访问或修改可变静态变量</li> <li>实现不安全 trait</li></ol> <p>有一点很重要，<code>unsafe</code> 并不会关闭借用检查器或禁用任何其他 Rust 安全检查：如果在不安全代码中使用引用，其仍会被检查。<code>unsafe</code> 关键字只是提供了那四个不会被编译器检查内存安全的功能。你仍然能在不安全块中获得某种程度的安全！</p> <p>再者，<code>unsafe</code> 不意味着块中的代码就一定是危险的或者必然导致内存安全问题：其意图在于作为程序员你将会确保 <code>unsafe</code> 块中的代码以有效的方式访问内存。</p> <p>人是会犯错误的，错误总会发生，不过通过要求这四类操作必须位于标记为 <code>unsafe</code> 的块中，就能够知道任何与内存安全相关的错误必定位于 <code>unsafe</code> 块内。保持 <code>unsafe</code> 块尽可能小，如此当之后调查内存 bug 时就会感谢你自己了。</p> <p>为了尽可能隔离不安全代码，将不安全代码封装进一个安全的抽象并提供安全 API 是一个好主意，当我们学习不安全函数和方法时会讨论到。标准库的一部分被实现为在被评审过的不安全代码之上的安全抽象。这个计数防止了 <code>unsafe</code> 泄露到所有你或者用户希望使用由 <code>unsafe</code> 代码实现的功能的地方，因为使用其安全抽象是安全的。</p> <p>让我们按顺序依次介绍上述四个超级力量，同时我们会看到一些提供不安全代码的安全接口的抽象。</p> <h3 id="解引用裸指针"><a href="#解引用裸指针" aria-hidden="true" class="header-anchor">#</a> 解引用裸指针</h3> <p>回到第四章的 “悬垂引用” 部分，那里提到了编译器会确保引用总是有效的。不安全 Rust 有两个被称为 <strong>裸指针</strong>（<em>raw pointers</em>）的类似于引用的新类型。和引用一样，裸指针是可变或不可变的，分别写作 <code>*const T</code> 和 <code>*mut T</code>。这里的星号不是解引用运算符；它是类型名称的一部分。在裸指针的上下文中，“裸指针” 意味着指针解引用之后不能直接赋值。</p> <p>与引用和智能指针的区别在于，记住裸指针</p> <ul><li>允许忽略借用规则，可以同时拥有不可变和可变的指针，或多个指向相同位置的可变指针</li> <li>不保证指向有效的内存</li> <li>允许为空</li> <li>不能实现任何自动清理功能</li></ul> <p>通过去掉 Rust 强加的保证，你可以放弃安全保证以换取性能或使用另一个语言或硬件接口的能力，此时 Rust 的保证并不适用。</p> <p>示例 19-1 展示了如何从引用同时创建不可变和可变裸指针。</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">let</span> <span class="token keyword">mut</span> num <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span>num <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">const</span> i32<span class="token punctuation">;</span>
<span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> num <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">mut</span> i32<span class="token punctuation">;</span>
</code></pre></div><p><span class="caption">示例 19-1: 通过引用创建裸指针</span></p> <p>注意这里没有引入 <code>unsafe</code> 关键字 ———— 可以在安全代码中 <strong>创建</strong> 裸指针，只是不能在不安全块之外 <strong>解引用</strong> 裸指针，稍后便会看到。</p> <p>这里使用 <code>as</code> 将不可变和可变引用强转为对应的裸指针类型。因为直接从保证安全的引用来创建他们，可以知道这些特定的裸指针是有效，但是不能对任何裸指针做出如此假设。</p> <p>接下来会创建一个不能确定其有效性的裸指针，示例 19-2 展示了如何创建一个指向任意内存地址的裸指针。尝试使用任意内存是未定义行为：此地址可能有数据也可能没有，编译器可能会优化掉这个内存访问，或者程序可能会出现段错误（segfault）。通常没有好的理由编写这样的代码，不过却是可行的：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">let</span> address <span class="token operator">=</span> 0x012345usize<span class="token punctuation">;</span>
<span class="token keyword">let</span> r <span class="token operator">=</span> address <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">const</span> i32<span class="token punctuation">;</span>
</code></pre></div><p><span class="caption">示例 19-2: 创建指向任意内存地址的裸指针</span></p> <p>记得我们说过可以在安全代码中创建裸指针，不过不能 <strong>解引用</strong> 裸指针和读取其指向的数据。现在我们要做的就是对裸指针使用解引用运算符 <code>*</code>，只要求一个 <code>unsafe</code> 块，如示例 19-3 所示：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">let</span> <span class="token keyword">mut</span> num <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span>num <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">const</span> i32<span class="token punctuation">;</span>
<span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> num <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">mut</span> i32<span class="token punctuation">;</span>

<span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;r1 is: {}&quot;</span><span class="token punctuation">,</span> <span class="token operator">*</span>r1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;r2 is: {}&quot;</span><span class="token punctuation">,</span> <span class="token operator">*</span>r2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><span class="caption">示例 19-3: 在 <code>unsafe</code> 块中解引用裸指针</span></p> <p>创建一个指针不会造成任何危险；只有当访问其指向的值时才有可能遇到无效的值。</p> <p>还需注意示例 19-1 和 19-3 中创建了同时指向相同内存位置 <code>num</code> 的裸指针 <code>*const i32</code> 和 <code>*mut i32</code>。相反如果尝试创建 <code>num</code> 的不可变和可变引用，这将无法编译因为 Rust 的所有权规则不允许拥有可变引用的同时拥有不可变引用。通过裸指针，就能够同时创建同一地址的可变指针和不可变指针，若通过可变指针修改数据，则可能潜在造成数据竞争。请多加小心！</p> <p>既然存在这么多的危险，为何还要使用裸指针呢？一个主要的应用场景便是调用 C 代码接口，这在下一部分不安全函数中会讲到。另一个场景是构建借用检查器无法理解的安全抽象。让我们先介绍不安全函数，接着看一看使用不安全代码的安全抽象的例子。</p> <h3 id="调用不安全函数或方法"><a href="#调用不安全函数或方法" aria-hidden="true" class="header-anchor">#</a> 调用不安全函数或方法</h3> <p>第二类要求使用不安全块的操作是调用不安全函数。不安全函数和方法与常规函数方法十分类似，除了其开头有一个额外的 <code>unsafe</code>。<code>unsafe</code> 表明我们作为程序需要满足其要求，因为 Rust 不会保证满足这些要求。通过在 <code>unsafe</code> 块中调用不安全函数，我们表明已经阅读过此函数的文档并对其是否满足函数自身的契约负责。</p> <p>如下是一个没有做任何操作的不安全函数 <code>dangerous</code> 的例子：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">unsafe</span> <span class="token keyword">fn</span> <span class="token function">dangerous</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
    <span class="token function">dangerous</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>必须在一个单独的 <code>unsafe</code> 块中调用 <code>dangerous</code> 函数。如果尝试不使用 <code>unsafe</code> 块调用 <code>dangerous</code>，则会得到一个错误：</p> <div class="language-text extra-class"><pre class="language-text"><code>error[E0133]: call to unsafe function requires unsafe function or block
 --&gt;
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
</code></pre></div><p>通过将 <code>dangerous</code> 调用插入 <code>unsafe</code> 块中，我们就向 Rust 保证了我们已经阅读过函数的文档，理解如何正确，并验证过所有内容的正确性。</p> <p>不安全函数体也是有效的 <code>unsafe</code> 块，所以在不安全函数中进行另一个不安全操作时无需新增额外的 <code>unsafe</code> 块。</p> <h4 id="创建不安全代码的安全抽象"><a href="#创建不安全代码的安全抽象" aria-hidden="true" class="header-anchor">#</a> 创建不安全代码的安全抽象</h4> <p>仅仅因为函数包含不安全代码并不意味着整个函数都需要标记为不安全的。事实上，将不安全代码封装进安全函数是一个常见的抽象。作为一个例子，标准库中的函数，<code>split_at_mut</code>，它需要一些不安全代码，让我们探索如何可以实现它。这个安全函数定义于可变 slice 之上：它获取一个 slice 并从给定的索引参数开始将其分为两个 slice。<code>split_at_mut</code> 的用法如示例 19-4 所示：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">let</span> <span class="token keyword">mut</span> v <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> r <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> v<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">split_at_mut</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">assert_eq!</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assert_eq!</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><span class="caption">示例 19-4: 使用安全的 <code>split_at_mut</code> 函数</span></p> <p>这个函数无法只通过安全 Rust 实现。一个尝试可能看起来像示例 19-5，它不能编译。处于简单考虑，我们将 <code>split_at_mut</code> 实现为函数而不是方法，并只处理 <code>i32</code> 值而非泛型 <code>T</code> 的 slice。</p> <p>用安全的Rust代码是不能实现这个函数的. 如果要试一下用安全的Rust来实现它可以参考例19-5. 简单起见, 我们把<code>split_at_mut</code>实现成一个函数而不是一个方法, 这个函数只处理<code>i32</code>类型的切片而不是泛型类型<code>T</code>的切片:</p> <div class="language-rust,ignore extra-class"><pre class="language-text"><code>fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();

    assert!(mid &lt;= len);

    (&amp;mut slice[..mid],
     &amp;mut slice[mid..])
}
</code></pre></div><p><span class="caption">示例 19-5: 尝试只使用安全 Rust 来实现 <code>split_at_mut</code></span></p> <p>此函数有限获取 slice 的长度，然后通过检查参数是否小于或等于这个长度来断言参数所给定的索引位于 slice 当中。该断言意味着如果传入的索引比要分割的 slice 的索引更大，此函数在尝试使用这个索引前 panic。</p> <p>次后我们在一个元组中返回两个可变的 slice：一个从原始 slice 的开头直到 <code>mid</code> 索引，另一个从 <code>mid</code> 直到原 slice 的结尾。</p> <p>如果尝试编译此代码，会得到一个错误：</p> <div class="language-text extra-class"><pre class="language-text"><code>error[E0499]: cannot borrow `*slice` as mutable more than once at a time
 --&gt;
  |
6 |     (&amp;mut slice[..mid],
  |           ----- first mutable borrow occurs here
7 |      &amp;mut slice[mid..])
  |           ^^^^^ second mutable borrow occurs here
8 | }
  | - first borrow ends here
</code></pre></div><p>Rust 的借用检查器不能理解我们要借用这个 slice 的两个不同部分：它只知道我们借用了同一个 slice 两次。本质上借用 slice 的不同部分是可以的，因为这样两个 slice 不会重叠，不过 Rust 还没有智能到理解这些。当我们知道某些事是可以的而 Rust 不知道的时候，就是触及不安全代码的时候了</p> <p>示例 19-6 展示了如何使用 <code>unsafe</code> 块，裸指针和一些不安全函数调用来实现 <code>split_at_mut</code>：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>slice<span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function">split_at_mut</span><span class="token punctuation">(</span>slice<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token punctuation">[</span>i32<span class="token punctuation">]</span><span class="token punctuation">,</span> mid<span class="token punctuation">:</span> usize<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token punctuation">[</span>i32<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token punctuation">[</span>i32<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> len <span class="token operator">=</span> slice<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> ptr <span class="token operator">=</span> slice<span class="token punctuation">.</span><span class="token function">as_mut_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">assert!</span><span class="token punctuation">(</span>mid <span class="token operator">&lt;=</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token punctuation">(</span>slice<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from_raw_parts_mut</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">,</span>
         slice<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from_raw_parts_mut</span><span class="token punctuation">(</span>ptr<span class="token punctuation">.</span><span class="token function">offset</span><span class="token punctuation">(</span>mid <span class="token keyword">as</span> isize<span class="token punctuation">)</span><span class="token punctuation">,</span> len <span class="token operator">-</span> mid<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><span class="caption">示例 19-6: 在 <code>split_at_mut</code> 函数的实现中使用不安全代码</span></p> <p>回忆第四章的 “Slice” 部分，slice 是一个指向一些数据的指针，并带有该 slice 的长度。可以使用 <code>len</code> 方法获取 slice 的长度，使用 <code>as_mut_ptr</code> 方法访问 slice 的裸指针。在这个例子中，因为有一个 <code>i32</code> 值的可变 slice，<code>as_mut_ptr</code> 返回一个 <code>*mut i32</code> 类型的裸指针，储存在 <code>ptr</code> 变量中。</p> <p>我们保持索引 <code>mid</code> 位于 slice 中的断言。接着是不安全代码：<code>slice::from_raw_parts_mut</code> 函数获取一个裸指针和一个长度来创建一个 slice。这里使用此函数从 <code>ptr</code> 中创建了一个有 <code>mid</code> 个项的 slice。之后在 <code>ptr</code> 上调用 <code>offset</code> 方法并使用 <code>mid</code> 作为参数来获取一个从 <code>mid</code> 开始的裸指针，使用这个裸指针并以 <code>mid</code> 之后项的数量为长度创建一个 slice。</p> <p><code>slice::from_raw_parts_mut</code> 函数是不安全的因为它获取一个裸指针，并必须确信这个指针是有效的。裸指针上的 <code>offset</code> 方法也是不安全的，因为其必须确信此地址偏移量也是有效的指针。因此必须将 <code>slice::from_raw_parts_mut</code> 和 <code>offset</code> 放入 <code>unsafe</code> 块中以便能调用它们。通过观察代码，和增加 <code>mid</code> 必然小于等于 <code>len</code> 的断言，我们可以说 <code>unsafe</code> 块中所有的裸指针将是有效的 slice 中数据的指针。这是一个可以接受的 <code>unsafe</code> 的恰当用法。</p> <p>注意无需将 <code>split_at_mut</code> 函数的结果标记为 <code>unsafe</code>，并可以在安全 Rust 中调用此函数。我们创建了一个不安全代码的安全抽象，其代码以一种安全的方式使用了 <code>unsafe</code> 代码，因为其只从这个函数访问的数据中创建了有效的指针。</p> <p>与此相对，示例 19-7 中的 <code>slice::from_raw_parts_mut</code> 在使用 slice 时很有可能会崩溃。这段代码获取任意内存地址并创建了一个长为一万的 slice：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>slice<span class="token punctuation">;</span>

<span class="token keyword">let</span> address <span class="token operator">=</span> 0x012345usize<span class="token punctuation">;</span>
<span class="token keyword">let</span> r <span class="token operator">=</span> address <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">mut</span> i32<span class="token punctuation">;</span>

<span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
    slice<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from_raw_parts_mut</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p><span class="caption">示例 19-7: 通过任意内存地址创建 slice</span></p> <p>我们并不拥有这个任意地址的内存，也不能保证这段代码创建的 slice 包含有效的 <code>i32</code> 值。试图使用臆测为有效的 <code>slice</code> 会导致未定义的行为。</p> <h4 id="使用-extern-函数调用外部代码"><a href="#使用-extern-函数调用外部代码" aria-hidden="true" class="header-anchor">#</a> 使用 <code>extern</code> 函数调用外部代码</h4> <p>有时你的 Rust 代码可能需要与其他语言编写的代码交互。为此 Rust 有一个关键字，<code>extern</code>，有助于创建和使用 <strong>外部函数接口</strong>（<em>Foreign Function Interface</em>， FFI）。外部函数接口是一个编程语言用以定义函数的方式，其允许不同（外部）编程语言调用这些函数。</p> <p>示例 19-8 展示了如何集成 C 标准库中的 <code>abs</code> 函数。<code>extern</code> 块中声明的函数在 Rust 代码中总是不安全的。因为其他语言不会强制执行 Rust 的规则且 Rust 无法检查它们，所以确保其安全是程序员的责任：</p> <p><span class="filename">文件名: src/main.rs</span></p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">abs</span><span class="token punctuation">(</span>input<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> i32<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Absolute value of -3 according to C: {}&quot;</span><span class="token punctuation">,</span> <span class="token function">abs</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><span class="caption">示例 19-8: 声明并调用另一个语言中定义的 <code>extern</code> 函数</span></p> <p>在 <code>extern &quot;C&quot;</code> 块中，列出了我们希望能够调用的另一个语言中的外部函数的签名和名称。<code>&quot;C&quot;</code> 部分定义了外部函数所使用的 <strong>应用程序接口</strong>（<em>application binary interface</em>，ABI） —— ABI 定义了如何在汇编语言层面调用此函数。<code>&quot;C&quot;</code> ABI 是最常见的，并遵循 C 编程语言的 ABI。</p> <h5 id="通过其它语言调用-rust-函数"><a href="#通过其它语言调用-rust-函数" aria-hidden="true" class="header-anchor">#</a> 通过其它语言调用 Rust 函数</h5> <p>也可以使用 <code>extern</code> 来创建一个允许其他语言调用 Rust 函数的接口。不同于 <code>extern</code> 块，就在 <code>fn</code> 关键字之前增加 <code>extern</code> 关键字并指定所用到的 ABI。还需增加 <code>#[no_mangle]</code> 注解来告诉 Rust 编译器不要 mangle 此函数的名称。mangle 发生于当编译器将我们指定的函数名修改为不同的名称时，这会增加用于其他编译过程的额外信息，不过会使其名称更难以阅读。每一个编程语言的编译器都会以稍微不同的方式 mangle 函数名，所以为了使 Rust 函数能在其他语言中指定，必须禁用 Rust 编译器的 name mangling。</p> <p>在如下的例子中，一旦其编译为动态库并从 C 语言中链接，<code>call_from_c</code> 函数就能够在 C 代码中访问：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token attribute attr-name">#[no_mangle]</span>
<span class="token keyword">pub</span> <span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token keyword">fn</span> <span class="token function">call_from_c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Just called a Rust function from C!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>extern</code> 的使用无需 <code>unsafe</code>。</p> <h3 id="访问或修改可变静态变量"><a href="#访问或修改可变静态变量" aria-hidden="true" class="header-anchor">#</a> 访问或修改可变静态变量</h3> <p>目前为止全书都尽量避免讨论 <strong>全局变量</strong>（<em>global variables</em>），Rust 确实支持他们，不过这对于 Rust 的所有权规则来说是有问题的。如果有两个线程访问相同的可变全局变量，则可能会造成数据竞争。</p> <p>全局变量在 Rust 中被称为 <strong>静态</strong>（<em>static</em>）变量。示例 19-9 展示了一个拥有字符串 slice 值的静态变量的声明和应用：</p> <p><span class="filename">文件名: src/main.rs</span></p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">static</span> HELLO_WORLD<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str <span class="token operator">=</span> <span class="token string">&quot;Hello, world!&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;name is: {}&quot;</span><span class="token punctuation">,</span> HELLO_WORLD<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><span class="caption">示例 19-9: 定义和使用一个不可变静态变量</span></p> <p><code>static</code> 变量类似于第三章 “变量和常量的区别” 部分讨论的常量。通常静态变量的名称采用 <code>SCREAMING_SNAKE_CASE</code> 写法，并 <strong>必须</strong> 标注变量的类型，在这个例子中是 <code>&amp;'static str</code>。静态变量只能储存拥有 <code>'static</code> 生命周期的引用，这意味着 Rust 编译器可以自己计算出其生命周期而无需显式标注。访问不可变静态变量是安全的。</p> <p>常量与不可变静态变量可能看起来很类似，不过一个微妙的区别是静态变量中的值有一个固定的内存地址。使用这个值总是会访问相同的地址。另一方面，常量则允许在任何被用到的时候复制其数据。</p> <p>常量与静态变量的另一个区别在于静态变量可以是可变的。访问和修改可变静态变量都是 <strong>不安全</strong> 的。示例 19-10 展示了如何声明、访问和修改名为 <code>COUNTER</code> 的可变静态变量：</p> <p><span class="filename">文件名: src/main.rs</span></p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">static</span> <span class="token keyword">mut</span> COUNTER<span class="token punctuation">:</span> u32 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function">add_to_count</span><span class="token punctuation">(</span>inc<span class="token punctuation">:</span> u32<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        COUNTER <span class="token operator">+=</span> inc<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">add_to_count</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;COUNTER: {}&quot;</span><span class="token punctuation">,</span> COUNTER<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><span class="caption">示例 19-10: 读取或修改一个可变静态变量是不安全的</span></p> <p>就像常规变量一样，我们使用 <code>mut</code> 关键来指定可变性。任何读写 <code>COUNTER</code> 的代码都必须位于 <code>unsafe</code> 块中。这段代码可以编译并如期打印出 <code>COUNTER: 3</code>，因为这是单线程的。拥有多个线程访问 <code>COUNTER</code> 则可能导致数据竞争。</p> <p>拥有可以全局访问的可变数据，难以保证不存在数据竞争，这就是为何 Rust 认为可变静态变量是不安全的。任何可能的情况，请优先使用第十六章讨论的并发技术和线程安全智能指针，这样编译器就能检测不同线程间的数据访问是安全的。</p> <h3 id="实现不安全-trait"><a href="#实现不安全-trait" aria-hidden="true" class="header-anchor">#</a> 实现不安全 trait</h3> <p>最后一个只能用在 <code>unsafe</code> 中的操作是实现不安全 trait。当至少有一个方法中包含编译器不能验证的不变量时 trait 是不安全的。可以在 <code>trait</code> 之前增加 <code>unsafe</code> 关键字将 trait 声明为 <code>unsafe</code>，同时 trait 的实现也必须标记为 <code>unsafe</code>，如示例 19-11 所示：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">unsafe</span> <span class="token keyword">trait</span> Foo <span class="token punctuation">{</span>
    <span class="token comment">// methods go here</span>
<span class="token punctuation">}</span>

<span class="token keyword">unsafe</span> <span class="token keyword">impl</span> Foo <span class="token keyword">for</span> i32 <span class="token punctuation">{</span>
    <span class="token comment">// method implementations go here</span>
<span class="token punctuation">}</span>
</code></pre></div><p><span class="caption">示例 19-11: 定义并实现不安全 trait</span></p> <p>通过 <code>unsafe impl</code>，我们承诺将保证编译器所不能验证的不变量。</p> <p>作为一个例子，回忆第十六章 “使用 <code>Sync</code> 和 <code>Send</code> trait 的可扩展并发” 部分中的 <code>Sync</code> 和 <code>Send</code> 标记 trait，编译器会自动为完全由 <code>Send</code> 和 <code>Sync</code> 类型组成的类型自动实现他们。如果实现了一个包含一些不是 <code>Send</code> 或 <code>Sync</code> 的类型，比如裸指针，并希望将此类型标记为 <code>Send</code> 或 <code>Sync</code>，则必须使用 <code>unsafe</code>。Rust 不能验证我们的类型保证可以安全的跨线程发送或在多线程键访问，所以需要我们自己进行检查并通过 <code>unsafe</code> 表明。</p> <h3 id="何时使用不安全代码"><a href="#何时使用不安全代码" aria-hidden="true" class="header-anchor">#</a> 何时使用不安全代码</h3> <p>使用 <code>unsafe</code> 来进行这四个操作之一是没有问题的，甚至是不需要深思熟虑的，不过使得 <code>unsafe</code> 代码正确也实属不易因为编译器不能帮助保证内存安全。当有理由使用 <code>unsafe</code> 代码时，是可以这么做的，通过使用显式的 <code>unsafe</code> 标注使得在出现错误时易于追踪问题的源头。</p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/98.2859c908.js" defer></script><script src="/assets/js/app.b56e4aff.js" defer></script>
  </body>
</html>
